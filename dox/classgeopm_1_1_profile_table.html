<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>geopm: geopm::ProfileTable Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">geopm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegeopm.html">geopm</a></li><li class="navelem"><a class="el" href="classgeopm_1_1_profile_table.html">ProfileTable</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classgeopm_1_1_profile_table-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">geopm::ProfileTable Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_profile_table_8hpp_source.html">ProfileTable.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for geopm::ProfileTable:</div>
<div class="dyncontent">
<div class="center"><img src="classgeopm_1_1_profile_table__inherit__graph.png" border="0" usemap="#geopm_1_1_profile_table_inherit__map" alt="Inheritance graph"/></div>
<map name="geopm_1_1_profile_table_inherit__map" id="geopm_1_1_profile_table_inherit__map">
<area shape="rect" id="node2" href="classgeopm_1_1_i_profile_table.html" title="Container for multi&#45;threaded or multi&#45;process producer consumer data exchange. " alt="" coords="5,5,147,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for geopm::ProfileTable:</div>
<div class="dyncontent">
<div class="center"><img src="classgeopm_1_1_profile_table__coll__graph.png" border="0" usemap="#geopm_1_1_profile_table_coll__map" alt="Collaboration graph"/></div>
<map name="geopm_1_1_profile_table_coll__map" id="geopm_1_1_profile_table_coll__map">
<area shape="rect" id="node2" href="classgeopm_1_1_i_profile_table.html" title="Container for multi&#45;threaded or multi&#45;process producer consumer data exchange. " alt="" coords="5,5,147,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac38ef18ea542f30af586c15d60d6cbff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_profile_table.html#ac38ef18ea542f30af586c15d60d6cbff">ProfileTable</a> (size_t <a class="el" href="classgeopm_1_1_profile_table.html#a94f36f2bda194803de206b1e6becb0c5">size</a>, void *buffer)</td></tr>
<tr class="memdesc:ac38ef18ea542f30af586c15d60d6cbff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for the <a class="el" href="classgeopm_1_1_profile_table.html">ProfileTable</a>.  <a href="#ac38ef18ea542f30af586c15d60d6cbff">More...</a><br /></td></tr>
<tr class="separator:ac38ef18ea542f30af586c15d60d6cbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec1d4a14c1a7f8bc69cce6af59beca8"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_profile_table.html#acec1d4a14c1a7f8bc69cce6af59beca8">~ProfileTable</a> ()=default</td></tr>
<tr class="memdesc:acec1d4a14c1a7f8bc69cce6af59beca8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgeopm_1_1_profile_table.html">ProfileTable</a> destructor, virtual.  <a href="#acec1d4a14c1a7f8bc69cce6af59beca8">More...</a><br /></td></tr>
<tr class="separator:acec1d4a14c1a7f8bc69cce6af59beca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e163edc3174691bad08245ebfcf552"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_profile_table.html#ab0e163edc3174691bad08245ebfcf552">key</a> (const std::string &amp;name) override</td></tr>
<tr class="memdesc:ab0e163edc3174691bad08245ebfcf552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash the name string into a random 64 bit integer.  <a href="#ab0e163edc3174691bad08245ebfcf552">More...</a><br /></td></tr>
<tr class="separator:ab0e163edc3174691bad08245ebfcf552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf46c453103326cb7627056369ea970a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_profile_table.html#adf46c453103326cb7627056369ea970a">insert</a> (uint64_t <a class="el" href="classgeopm_1_1_profile_table.html#ab0e163edc3174691bad08245ebfcf552">key</a>, const struct <a class="el" href="structgeopm__prof__message__s.html">geopm_prof_message_s</a> &amp;value) override</td></tr>
<tr class="memdesc:adf46c453103326cb7627056369ea970a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a value into the table.  <a href="#adf46c453103326cb7627056369ea970a">More...</a><br /></td></tr>
<tr class="separator:adf46c453103326cb7627056369ea970a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997972917372ba4b77bace577e70aacc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_profile_table.html#a997972917372ba4b77bace577e70aacc">capacity</a> (void) const override</td></tr>
<tr class="memdesc:a997972917372ba4b77bace577e70aacc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of entries the table can hold.  <a href="#a997972917372ba4b77bace577e70aacc">More...</a><br /></td></tr>
<tr class="separator:a997972917372ba4b77bace577e70aacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f36f2bda194803de206b1e6becb0c5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_profile_table.html#a94f36f2bda194803de206b1e6becb0c5">size</a> (void) const override</td></tr>
<tr class="separator:a94f36f2bda194803de206b1e6becb0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80555396debcd989bc1bb6e322dc78f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_profile_table.html#a80555396debcd989bc1bb6e322dc78f2">dump</a> (std::vector&lt; std::pair&lt; uint64_t, struct <a class="el" href="structgeopm__prof__message__s.html">geopm_prof_message_s</a> &gt; &gt;::iterator content, size_t &amp;length) override</td></tr>
<tr class="memdesc:a80555396debcd989bc1bb6e322dc78f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all table entries into a vector and delete all entries.  <a href="#a80555396debcd989bc1bb6e322dc78f2">More...</a><br /></td></tr>
<tr class="separator:a80555396debcd989bc1bb6e322dc78f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fc7bf515ddbe04e0c8cf200b561eb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_profile_table.html#af7fc7bf515ddbe04e0c8cf200b561eb9">name_fill</a> (size_t header_offset) override</td></tr>
<tr class="memdesc:af7fc7bf515ddbe04e0c8cf200b561eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the producer to pass names to the consumer.  <a href="#af7fc7bf515ddbe04e0c8cf200b561eb9">More...</a><br /></td></tr>
<tr class="separator:af7fc7bf515ddbe04e0c8cf200b561eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89235fb2e832e0f745ef8b19b8bcbb88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_profile_table.html#a89235fb2e832e0f745ef8b19b8bcbb88">name_set</a> (size_t header_offset, std::set&lt; std::string &gt; &amp;name) override</td></tr>
<tr class="memdesc:a89235fb2e832e0f745ef8b19b8bcbb88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the consumer to receive the names that hash to the keys.  <a href="#a89235fb2e832e0f745ef8b19b8bcbb88">More...</a><br /></td></tr>
<tr class="separator:a89235fb2e832e0f745ef8b19b8bcbb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classgeopm_1_1_i_profile_table"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classgeopm_1_1_i_profile_table')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classgeopm_1_1_i_profile_table.html">geopm::IProfileTable</a></td></tr>
<tr class="memitem:adeba4ad46b15172e988982d518e660ff inherit pub_methods_classgeopm_1_1_i_profile_table"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_i_profile_table.html#adeba4ad46b15172e988982d518e660ff">IProfileTable</a> ()=default</td></tr>
<tr class="separator:adeba4ad46b15172e988982d518e660ff inherit pub_methods_classgeopm_1_1_i_profile_table"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f19f53630ccef1a01b46c793582bce inherit pub_methods_classgeopm_1_1_i_profile_table"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_i_profile_table.html#a50f19f53630ccef1a01b46c793582bce">~IProfileTable</a> ()=default</td></tr>
<tr class="separator:a50f19f53630ccef1a01b46c793582bce inherit pub_methods_classgeopm_1_1_i_profile_table"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac38ef18ea542f30af586c15d60d6cbff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38ef18ea542f30af586c15d60d6cbff">&#9670;&nbsp;</a></span>ProfileTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">geopm::ProfileTable::ProfileTable </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for the <a class="el" href="classgeopm_1_1_profile_table.html">ProfileTable</a>. </p>
<p>The memory that is used by the container is provided at construction time. There are other ancillary data associated with the structure which are dynamic, but the data container is of fixed size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>[in] The length of the buffer in bytes.</td></tr>
    <tr><td class="paramname">buffer</td><td>[in] Pointer to beginning of virtual address range used for storing the data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acec1d4a14c1a7f8bc69cce6af59beca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec1d4a14c1a7f8bc69cce6af59beca8">&#9670;&nbsp;</a></span>~ProfileTable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual geopm::ProfileTable::~ProfileTable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classgeopm_1_1_profile_table.html">ProfileTable</a> destructor, virtual. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a997972917372ba4b77bace577e70aacc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997972917372ba4b77bace577e70aacc">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t geopm::ProfileTable::capacity </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum number of entries the table can hold. </p>
<p>Returns the upper bound on the number of values that can be stored in the table. This can be used to size the content vector passed to the <a class="el" href="classgeopm_1_1_profile_table.html#a80555396debcd989bc1bb6e322dc78f2" title="Copy all table entries into a vector and delete all entries. ">dump()</a> method. In general there will be many fewer entries into the table than the number returned by <a class="el" href="classgeopm_1_1_profile_table.html#a997972917372ba4b77bace577e70aacc" title="Maximum number of entries the table can hold. ">capacity()</a> before a <a class="el" href="classgeopm_1_1_exception.html" title="Class for all GEOPM-specific exceptions. ">geopm::Exception</a> with error_value() of GEOPM_TOO_MANY_COLLISIONS is thrown at time of insertion.</p>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of entries the table can hold. </dd></dl>

<p>Implements <a class="el" href="classgeopm_1_1_i_profile_table.html#a70326659a4f26d9243c0121f703aa4e0">geopm::IProfileTable</a>.</p>

</div>
</div>
<a id="a80555396debcd989bc1bb6e322dc78f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80555396debcd989bc1bb6e322dc78f2">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void geopm::ProfileTable::dump </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; uint64_t, struct <a class="el" href="structgeopm__prof__message__s.html">geopm_prof_message_s</a> &gt; &gt;::iterator&#160;</td>
          <td class="paramname"><em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy all table entries into a vector and delete all entries. </p>
<p>This method is used by the data consumer to empty the table of all posted contents into a vector. When the table is used in this way it serves as a temporary scratch-pad for relaying messages from the producer to the consumer. Note that the content vector is not re-sized and it should be sized according to the value returned by <a class="el" href="classgeopm_1_1_profile_table.html#a997972917372ba4b77bace577e70aacc" title="Maximum number of entries the table can hold. ">capacity()</a>. Only the first "length" elements of the vector will be written to by <a class="el" href="classgeopm_1_1_profile_table.html#a80555396debcd989bc1bb6e322dc78f2" title="Copy all table entries into a vector and delete all entries. ">dump()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">content</td><td>The vector of key value pairs copied out of the table.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">length</td><td>The number of entries copied into the content vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgeopm_1_1_i_profile_table.html#ac373252b0ebd763e97e619feec1fcba9">geopm::IProfileTable</a>.</p>

</div>
</div>
<a id="adf46c453103326cb7627056369ea970a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf46c453103326cb7627056369ea970a">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void geopm::ProfileTable::insert </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structgeopm__prof__message__s.html">geopm_prof_message_s</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a value into the table. </p>
<p>Once the name has been registered with a call to <a class="el" href="classgeopm_1_1_profile_table.html#ab0e163edc3174691bad08245ebfcf552" title="Hash the name string into a random 64 bit integer. ">key()</a> the data associated with the name can be inserted into the table by the producer using this function. If there is already a value associated with the key then the value will be overwritten. There is a fixed number of collisions allowed, and if too many keys hashed to the same entry in the table, the entry will be emptied of it's current data which will be lost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The value returned by <a class="el" href="classgeopm_1_1_profile_table.html#ab0e163edc3174691bad08245ebfcf552" title="Hash the name string into a random 64 bit integer. ">key()</a> when the name was registered.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Entry that is to be inserted into the table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the 64 bit hash used to reference the name in other <a class="el" href="classgeopm_1_1_profile_table.html">ProfileTable</a> methods. </dd></dl>

<p>Implements <a class="el" href="classgeopm_1_1_i_profile_table.html#a98d7e17d1e4e6b6b729da7a61ca405c2">geopm::IProfileTable</a>.</p>

</div>
</div>
<a id="ab0e163edc3174691bad08245ebfcf552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e163edc3174691bad08245ebfcf552">&#9670;&nbsp;</a></span>key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t geopm::ProfileTable::key </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hash the name string into a random 64 bit integer. </p>
<p>Uses the <a class="el" href="geopm__hash_8c.html#a3618c5db703759ced79117700cb41024">geopm_crc32_str()</a> function to hash the name which will modify the lower 32 bits. The remaining 32 bits may be used for other purposes in the future. Subsequent calls to hash the same string will use a string to integer std::map rather than re-hashing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>String which is to be mapped to the key. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgeopm_1_1_i_profile_table.html#a315190a399f0c65562b230b628212c72">geopm::IProfileTable</a>.</p>

</div>
</div>
<a id="af7fc7bf515ddbe04e0c8cf200b561eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7fc7bf515ddbe04e0c8cf200b561eb9">&#9670;&nbsp;</a></span>name_fill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool geopm::ProfileTable::name_fill </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>header_offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by the producer to pass names to the consumer. </p>
<p>When this method is called the data producer will pass the names that have been thus far been passed to <a class="el" href="classgeopm_1_1_profile_table.html#ab0e163edc3174691bad08245ebfcf552" title="Hash the name string into a random 64 bit integer. ">key()</a> through the buffer to the consumer who will call <a class="el" href="classgeopm_1_1_profile_table.html#a89235fb2e832e0f745ef8b19b8bcbb88" title="Called by the consumer to receive the names that hash to the keys. ">name_set()</a> to receive the names. There is an option to avoid writing to the beginning of the buffer so that it can be reserved for passing other information. If the header_offset is zero then the entire buffer is used. This call will block until the consumer calls <a class="el" href="classgeopm_1_1_profile_table.html#a89235fb2e832e0f745ef8b19b8bcbb88" title="Called by the consumer to receive the names that hash to the keys. ">name_set()</a>.</p>
<p>NOTE: The <a class="el" href="classgeopm_1_1_profile_table.html">ProfileTable</a> cannot be used again after a call to <a class="el" href="classgeopm_1_1_profile_table.html#af7fc7bf515ddbe04e0c8cf200b561eb9" title="Called by the producer to pass names to the consumer. ">name_fill()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">header_offset</td><td>Offset in bytes to where the name values will start in the buffer. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgeopm_1_1_i_profile_table.html#a09812b444002d97d9c842915ec311e5c">geopm::IProfileTable</a>.</p>

</div>
</div>
<a id="a89235fb2e832e0f745ef8b19b8bcbb88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89235fb2e832e0f745ef8b19b8bcbb88">&#9670;&nbsp;</a></span>name_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool geopm::ProfileTable::name_set </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>header_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by the consumer to receive the names that hash to the keys. </p>
<p>Through calling <a class="el" href="classgeopm_1_1_profile_table.html#a80555396debcd989bc1bb6e322dc78f2" title="Copy all table entries into a vector and delete all entries. ">dump()</a> the consumer will receive a set of integer keys. This method enables the consumer to learn the names that can be hashed to the keys it has received. There is an option to avoid writing to the beginning of the buffer so that it can be reserved for passing other information. If the header_offset is zero then the entire buffer is used. This call will block until the producer calls <a class="el" href="classgeopm_1_1_profile_table.html#af7fc7bf515ddbe04e0c8cf200b561eb9" title="Called by the producer to pass names to the consumer. ">name_fill()</a>.</p>
<p>NOTE: The <a class="el" href="classgeopm_1_1_profile_table.html">ProfileTable</a> cannot be used again after a call to <a class="el" href="classgeopm_1_1_profile_table.html#a89235fb2e832e0f745ef8b19b8bcbb88" title="Called by the consumer to receive the names that hash to the keys. ">name_set()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">header_offset</td><td>Offset in bytes to where the name values will start in the buffer.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">name</td><td>Set of names read from output of the producer's call to <a class="el" href="classgeopm_1_1_profile_table.html#af7fc7bf515ddbe04e0c8cf200b561eb9" title="Called by the producer to pass names to the consumer. ">name_fill()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgeopm_1_1_i_profile_table.html#a0f6c5340d7408d48831370d4e822aac3">geopm::IProfileTable</a>.</p>

</div>
</div>
<a id="a94f36f2bda194803de206b1e6becb0c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f36f2bda194803de206b1e6becb0c5">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t geopm::ProfileTable::size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classgeopm_1_1_i_profile_table.html#a647e8ae2ffd502cc667c7c8f8faf23e8">geopm::IProfileTable</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_profile_table_8hpp_source.html">ProfileTable.hpp</a></li>
<li>src/<a class="el" href="_profile_table_8cpp.html">ProfileTable.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
