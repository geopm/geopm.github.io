

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>geopm_pio_msr(7) – Signals and controls for Model Specific Registers (MSRs) &mdash; GEOPM  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=5929fcd5"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="geopm_pio_nvml(7) – IOGroup providing signals and controls for NVIDIA GPUs" href="geopm_pio_nvml.7.html" />
    <link rel="prev" title="geopm_pio_levelzero(7) – IOGroup providing signals and controls for Intel GPUs" href="geopm_pio_levelzero.7.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            GEOPM
              <img src="https://geopm.github.io/images/geopm-logo-clear.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="user_guides.html">User Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="contrib.html">Contributor Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="devel.html">Developer Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="publications.html">Publications</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="reference.html">Reference Manual</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="reference.html#geopm-manual-pages">GEOPM Manual Pages</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="geopm.7.html">geopm(7) – Global Extensible Open Power Manager</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_pio.7.html">geopm_pio(7) – GEOPM PlatformIO interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_pio_cnl.7.html">geopm_pio_cnl(7) – Signals and controls for Compute Node Linux Board-Level Metrics</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_pio_const_config.7.html">geopm_pio_const_config(7) – Signals for ConstConfigIOGroup</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_pio_cpuinfo.7.html">geopm_pio_cpuinfo(7) – Signals and controls for the CPUInfoIOGroup</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_pio_dcgm.7.html">geopm_pio_dcgm(7) – IOGroup providing signals and controls for NVIDIA GPUs</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_pio_levelzero.7.html">geopm_pio_levelzero(7) – IOGroup providing signals and controls for Intel GPUs</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">geopm_pio_msr(7) – Signals and controls for Model Specific Registers (MSRs)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#description">Description</a></li>
<li class="toctree-l4"><a class="reference internal" href="#signals">Signals</a></li>
<li class="toctree-l4"><a class="reference internal" href="#controls">Controls</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aliases">Aliases</a></li>
<li class="toctree-l4"><a class="reference internal" href="#example">Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#see-also">See Also</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="geopm_pio_nvml.7.html">geopm_pio_nvml(7) – IOGroup providing signals and controls for NVIDIA GPUs</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_pio_profile.7.html">geopm_pio_profile(7) – Signals and controls for the ProfileIOGroup</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_pio_service.7.html">geopm_pio_service(7) – Signals and controls for the ServiceIOGroup</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_pio_sst.7.html">geopm_pio_sst(7) – Signals and controls for Intel Speed Select Technology</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_pio_sysfs.7.html">geopm_pio_sysfs(7) – Signals and controls for sysfs attributes</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_pio_time.7.html">geopm_pio_time(7) – Signals and controls for Time IO Group</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopmaccess.1.html">geopmaccess(1) – Access management for the GEOPM Service</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopmadmin.1.html">geopmadmin(1) – tool for GEOPM system administrators</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopmagent.1.html">geopmagent(1) – query agent information and create static policies</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopmbench.1.html">geopmbench(1) – synthetic benchmark application</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopmctl.1.html">geopmctl(1) – GEOPM runtime control application</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopmendpoint.1.html">geopmendpoint(1) – command line tool for dynamic policy control</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopmexporter.1.html">geopmexporter(1) – Prometheus exporter for GEOPM metrics</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopmlaunch.1.html">geopmlaunch(1) – application launch wrapper</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopmread.1.html">geopmread(1) – query platform information</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopmsession.1.html">geopmsession(1) – Command line interface for the GEOPM service batch read features</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopmwrite.1.html">geopmwrite(1) – modify platform state</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopmdpy.7.html">geopmdpy(7) – global extensible open power manager python daemon package</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopmpy.7.html">geopmpy(7) – global extensible open power manager python package</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_agent.3.html">geopm_agent(3) – query information about available agents</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_ctl.3.html">geopm_ctl(3) – GEOPM runtime control thread</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_daemon.3.html">geopm_daemon(3) – helpers for GEOPM daemons</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_endpoint.3.html">geopm_endpoint(3) – dynamic policy control for resource management</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_error.3.html">geopm_error(3) – error code descriptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_field.3.html">geopm_agent(3) – query information about available agents</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_fortran.3.html">geopm_fortran(3) – GEOPM fortran interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_hash.3.html">geopm_hash(3) – helper methods for encoding</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_imbalancer.3.html">geopm_imbalancer(3) – set artificial runtime imbalance</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_pio.3.html">geopm_pio(3) – interfaces to query and modify platform</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_policystore.3.html">geopm_policystore(3) – GEOPM resource policy store interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_prof.3.html">geopm_prof(3) – application profiling interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_sched.3.html">geopm_sched(3) – interface with Linux scheduler</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_time.3.html">geopm_time(3) – helper methods for time</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_topo.3.html">geopm_topo(3) – query platform component topology</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_version.3.html">geopm_version(3) – GEOPM library version</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3AAgent.3.html">geopm::Agent(3) – GEOPM agent plugin interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3AAgg.3.html">geopm::Agg(3) – data aggregation functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3ACNLIOGroup.3.html">geopm::CNLIOGroup(3) – IOGroup for interaction with Compute Node Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3ACPUActivityAgent.3.html">geopm::CPUActivityAgent(3) – agent for selecting CPU frequency based on CPU compute activity</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3ACircularBuffer.3.html">geopm::CircularBuffer(3) – generic circular buffer</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3AComm.3.html">geopm::Comm(3) – communication abstractions</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3ACpuinfoIOGroup.3.html">geopm::CpuinfoIOGroup(3) – IOGroup for CPU frequency limits</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3ADaemon.3.html">geopm::Daemon(3) – GEOPM daemon helper methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3AEndpoint.3.html">geopm::Endpoint(3) – GEOPM endpoint interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3AException.3.html">geopm::Exception(3) – custom GEOPM exceptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3AGPUActivityAgent.3.html">geopm::GPUActivityAgent(3) – agent for selecting GPU frequency based on GPU compute activity</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3AHelper.3.html">geopm::Helper – common helper methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3AIOGroup.3.html">geopm::IOGroup(3) – provides system values and settings</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3AMPIComm.3.html">geopm::MPIComm(3) – implementation of Comm using MPI</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3AMSRIO.3.html">geopm::MSRIO(3) – methods for reading and writing MSRs</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3AMSRIOGroup.3.html">geopm::MSRIOGroup – IOGroup providing MSR-based signals and controls</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3AMonitorAgent.3.html">geopm::MonitorAgent – agent that enforces no policies</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3APlatformIO.3.html">geopm::PlatformIO(3) – GEOPM platform interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3APlatformTopo.3.html">geopm::PlatformTopo(3) – platform topology information</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3APluginFactory.3.html">geopm::PluginFactory(3) – abstract factory for plugins</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3APowerBalancer.3.html">geopm::PowerBalancer(3) – balances power according to epoch runtime</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3APowerBalancerAgent.3.html">geopm::PowerBalancerAgent(3) – agent optimizing performance under a power cap</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3APowerGovernor.3.html">geopm::PowerGovernor(3) – enforces a power limit</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3APowerGovernorAgent.3.html">geopm::PowerGovernorAgent(3) – agent that enforces a power cap</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3AProfileIOGroup.3.html">geopm::ProfileIOGroup(3) – IOGroup providing application signals</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3ASampleAggregator.3.html">geopm::SampleAggregator(3) – per-region aggregated signal data</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3ASharedMemory.3.html">geopm::SharedMemory(3) – abstractions for shared memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm%3A%3ATimeIOGroup.3.html">geopm::TimeIOGroup(3) – IOGroup providing time signals</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_report.7.html">geopm_report(7) – GEOPM summary report file</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_agent_cpu_activity.7.html">geopm_agent_cpu_activity(7) – agent for selecting CPU frequency based on CPU compute activity</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_agent_ffnet.7.html">geopm_agent_ffnet(7) – agent for adjusting frequencies based on application behavior</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_agent_frequency_map.7.html">geopm_agent_frequency_map(7) – agent for running regions at user selected frequencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_agent_gpu_activity.7.html">geopm_agent_gpu_activity(7) – agent for selecting GPU frequency based on GPU compute activity</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_agent_monitor.7.html">geopm_agent_monitor(7) – agent implementation for aggregating statistics</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_agent_power_balancer.7.html">geopm_agent_power_balancer(7) – agent optimizes performance under a power cap</a></li>
<li class="toctree-l3"><a class="reference internal" href="geopm_agent_power_governor.7.html">geopm_agent_power_governor(7) – agent enforces a power cap</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="reference.html#doxygen-pages">Doxygen Pages</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="releases.html">Releases</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">GEOPM</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="reference.html">Reference Manual</a></li>
      <li class="breadcrumb-item active">geopm_pio_msr(7) – Signals and controls for Model Specific Registers (MSRs)</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/geopm_pio_msr.7.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="geopm-pio-msr-7-signals-and-controls-for-model-specific-registers-msrs">
<h1>geopm_pio_msr(7) – Signals and controls for Model Specific Registers (MSRs)<a class="headerlink" href="#geopm-pio-msr-7-signals-and-controls-for-model-specific-registers-msrs" title="Link to this heading"></a></h1>
<section id="description">
<h2>Description<a class="headerlink" href="#description" title="Link to this heading"></a></h2>
<p>The MSR IOGroup implements the
<a class="reference internal" href="geopm%3A%3AIOGroup.3.html"><span class="doc">geopm::IOGroup(3)</span></a> interface to provide
hardware signals and controls for Model Specific Registers (MSRs).</p>
<section id="configuration">
<h3>Configuration<a class="headerlink" href="#configuration" title="Link to this heading"></a></h3>
<p>The set of signals and controls supported by the MSR IOGroup is configurable,
as the MSRs that are available depend on the architecture and the particular
CPU. The MSR IOGroup will declare a set of common signals and controls,
including MSRs for CPU performance, temperature and power.</p>
<p>Additional MSRs can be specified via configuration files. If the
<code class="docutils literal notranslate"><span class="pre">GEOPM_MSR_CONFIG_PATH</span></code> environment variable is set, the paths specified there
will be checked for any JSON files prefixed with <code class="docutils literal notranslate"><span class="pre">msr_</span></code>. The <code class="docutils literal notranslate"><span class="pre">/etc/geopm</span></code>
directory will also be searched. The files must follow this schema:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;$schema&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;http://json-schema.org/draft-04/schema#&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;id&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;https://geopm.github.io/msrs.schema.json&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;title&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;MSR specification&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;definitions&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;msrFields&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;object&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;properties&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="nt">&quot;begin_bit&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;integer&quot;</span>
<span class="w">          </span><span class="p">},</span>
<span class="w">          </span><span class="nt">&quot;end_bit&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;integer&quot;</span>
<span class="w">          </span><span class="p">},</span>
<span class="w">          </span><span class="nt">&quot;function&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;enum&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;log_half&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;7_bit_float&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;overflow&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;logic&quot;</span><span class="p">]</span>
<span class="w">          </span><span class="p">},</span>
<span class="w">          </span><span class="nt">&quot;units&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;enum&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;none&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;seconds&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;hertz&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;watts&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;joules&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;celsius&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;amperes&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;volts&quot;</span><span class="p">]</span>
<span class="w">          </span><span class="p">},</span>
<span class="w">          </span><span class="nt">&quot;scalar&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;number&quot;</span>
<span class="w">          </span><span class="p">},</span>
<span class="w">          </span><span class="nt">&quot;behavior&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;enum&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;monotone&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;variable&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;label&quot;</span><span class="p">]</span>
<span class="w">          </span><span class="p">},</span>
<span class="w">          </span><span class="nt">&quot;writeable&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;boolean&quot;</span>
<span class="w">          </span><span class="p">},</span>
<span class="w">          </span><span class="nt">&quot;aggregation&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;enum&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;sum&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;average&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;median&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;logical_and&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;logical_or&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;region_hash&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;region_hint&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;min&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;max&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;stddev&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;select_first&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;expect_same&quot;</span><span class="p">]</span>
<span class="w">          </span><span class="p">},</span>
<span class="w">          </span><span class="nt">&quot;description&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;string&quot;</span>
<span class="w">          </span><span class="p">}</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="nt">&quot;required&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;begin_bit&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;end_bit&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;function&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;scalar&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;units&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;writeable&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;behavior&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;aggregation&quot;</span><span class="p">],</span>
<span class="w">        </span><span class="nt">&quot;additionalProperties&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span>
<span class="w">      </span><span class="p">},</span>
<span class="w">      </span><span class="nt">&quot;msrObject&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;object&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;properties&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="nt">&quot;offset&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;string&quot;</span>
<span class="w">          </span><span class="p">},</span>
<span class="w">          </span><span class="nt">&quot;domain&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;enum&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;board&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;package&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;core&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;memory&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;package_integrated_memory&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;nic&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;package_integrated_nic&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;gpu&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;package_integrated_gpu&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;gpu_chip&quot;</span><span class="p">]</span>
<span class="w">          </span><span class="p">},</span>
<span class="w">          </span><span class="nt">&quot;fields&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;object&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="nt">&quot;additionalProperties&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="nt">&quot;$ref&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;#/definitions/msrFields&quot;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">          </span><span class="p">}</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="nt">&quot;required&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;offset&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;domain&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;fields&quot;</span><span class="p">],</span>
<span class="w">        </span><span class="nt">&quot;additionalProperties&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;object&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;properties&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;msrs&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;object&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nt">&quot;additionalProperties&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="nt">&quot;$ref&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;#/definitions/msrObject&quot;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;additionalProperties&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For an example of an MSR configuration file, please see:
<a class="reference external" href="https://github.com/geopm/geopm/blob/dev/examples/custom_msr/msr_reasons.json">&lt;msr_reasons.json&gt;</a></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Before GEOPM 3.0, MSR configuration files were stored near the GEOPM
library objects (e.g., in <code class="docutils literal notranslate"><span class="pre">/usr/lib64/geopm</span></code>), and discovered in the
search paths from the <code class="docutils literal notranslate"><span class="pre">GEOPM_PLUGIN_PATH</span></code> environment variable. Since
version 3.0, GEOPM additionally searches <code class="docutils literal notranslate"><span class="pre">/etc/geopm</span></code> and locations from
the <code class="docutils literal notranslate"><span class="pre">GEOPM_MSR_CONFIG_PATH</span></code> environment variable. Future releases may
stop searching the library and plugin paths for MSR configuration data.
If GEOPM uses a configuration from the old location, then a deprecation
warning is emitted.</p>
</div>
<p>This guide includes a list of signals and controls that are more commonly
available. Use geopmread and geopmwrite to query the full set of signals and
controls that are available on a particular system.</p>
</section>
<section id="concurrent-access">
<h3>Concurrent Access<a class="headerlink" href="#concurrent-access" title="Link to this heading"></a></h3>
<p>Usage and access to most MSRs is restricted to ring 0. However, there is
no hardware mechanism available to reserve access to MSRs, so access is on a
first-come-first-served basis. As a result, it’s possible for a process to
overwrite previously programmed settings by another process. So care must be
taken when using GEOPM with other tools that might also access and configure
MSRs (e.g. a Virtual Machine Monitor or a performance monitoring tool) to
avoid concurrent access and unexpected results.</p>
<p>Please consult the following for further information and guidelines for
sharing access to MSRs: Performance Monitoring Unit Sharing Guide (Intel white
paper).</p>
</section>
</section>
<section id="signals">
<h2>Signals<a class="headerlink" href="#signals" title="Link to this heading"></a></h2>
<p>Some MSR signals are available on specific miroarchitectures.
<a class="reference internal" href="#architectural-signals"><span class="std std-ref">Architectural signals</span></a> are
available across Intel x86 microarchitectures.</p>
<nav class="contents local" id="categories-of-msr-signals">
<p class="topic-title">Categories of MSR signals:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#architectural-signals" id="id1">Architectural Signals</a></p></li>
<li><p><a class="reference internal" href="#knights-landing-knl-signals" id="id2">Knights Landing (KNL) Signals</a></p></li>
<li><p><a class="reference internal" href="#sandy-bridge-snb-signals" id="id3">Sandy Bridge (SNB) Signals</a></p></li>
<li><p><a class="reference internal" href="#haswell-hsx-signals" id="id4">Haswell (HSX) Signals</a></p></li>
<li><p><a class="reference internal" href="#skylake-skx-signals" id="id5">Skylake (SKX) Signals</a></p></li>
</ul>
</nav>
<section id="architectural-signals">
<h3><a class="toc-backref" href="#id1" role="doc-backlink">Architectural Signals</a><a class="headerlink" href="#architectural-signals" title="Link to this heading"></a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate" id="msr-time-stamp-counter-timestamp-count"><span class="pre">MSR::TIME_STAMP_COUNTER:TIMESTAMP_COUNT</span></code></dt><dd><p>An always running, monotonically increasing counter that is incremented at a constant rate.  For use as a wall clock timer.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: select_first</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-mperf-mcnt"><span class="pre">MSR::MPERF:MCNT</span></code></dt><dd><p>A counter incrementing at the processor’s base, maximum performance frequency. This counter cannot measure processor performance when the CPU is inactive.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-aperf-acnt"><span class="pre">MSR::APERF:ACNT</span></code></dt><dd><p>A counter incrementing at the processor’s actual frequency. This counter cannot measure processor performance when the CPU is inactive.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-therm-interrupt-thresh-1"><span class="pre">MSR::THERM_INTERRUPT:THRESH_1</span></code></dt><dd><p>The temperature at or above which the <a class="reference internal" href="#msr-therm-status-thermal-thresh-1-status"><span class="std std-ref">MSR::THERM_STATUS:THERMAL_THRESH_1_STATUS</span></a> indicator is set, in degrees below <a class="reference internal" href="#msr-temperature-target-prochot-min"><span class="std std-ref">MSR::TEMPERATURE_TARGET:PROCHOT_MIN</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: celsius</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-therm-interrupt-thresh-2"><span class="pre">MSR::THERM_INTERRUPT:THRESH_2</span></code></dt><dd><p>The temperature at or above which the <a class="reference internal" href="#msr-therm-status-thermal-thresh-2-status"><span class="std std-ref">MSR::THERM_STATUS:THERMAL_THRESH_2_STATUS</span></a> indicator is set, in degrees below <a class="reference internal" href="#msr-temperature-target-prochot-min"><span class="std std-ref">MSR::TEMPERATURE_TARGET:PROCHOT_MIN</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: celsius</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-therm-status-thermal-status-flag"><span class="pre">MSR::THERM_STATUS:THERMAL_STATUS_FLAG</span></code></dt><dd><p>Indicates whether the core’s on-die sensor reads a high temperature (PROCHOT). When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-therm-status-prochot-event"><span class="pre">MSR::THERM_STATUS:PROCHOT_EVENT</span></code></dt><dd><p>Indicates whether a high temperature (PROCHOT) or forced power reduction (FORCEPR) is being externally asserted. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-therm-status-critical-temp-status"><span class="pre">MSR::THERM_STATUS:CRITICAL_TEMP_STATUS</span></code></dt><dd><p>Indicates whether the core’s on-die sensor reads a critical temperature and the system cannot guarantee reliable operation. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-therm-status-thermal-thresh-1-status"><span class="pre">MSR::THERM_STATUS:THERMAL_THRESH_1_STATUS</span></code></dt><dd><p>Indicates whether the core’s on-die sensor reads equal to or hotter than the threshold in <a class="reference internal" href="#msr-therm-interrupt-thresh-1"><span class="std std-ref">MSR::THERM_INTERRUPT:THRESH_1</span></a>. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-therm-status-thermal-thresh-2-status"><span class="pre">MSR::THERM_STATUS:THERMAL_THRESH_2_STATUS</span></code></dt><dd><p>Indicates whether the core’s on-die sensor reads equal to or hotter than the threshold in <a class="reference internal" href="#msr-therm-interrupt-thresh-2"><span class="std std-ref">MSR::THERM_INTERRUPT:THRESH_2</span></a>. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-therm-status-power-limit-status"><span class="pre">MSR::THERM_STATUS:POWER_LIMIT_STATUS</span></code></dt><dd><p>Indicates whether requested P-States or requested clock duty cycles are not met. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-therm-status-digital-readout"><span class="pre">MSR::THERM_STATUS:DIGITAL_READOUT</span></code></dt><dd><p>The temperature reading on this core’s on-die sensor, in degrees below <a class="reference internal" href="#msr-temperature-target-prochot-min"><span class="std std-ref">MSR::TEMPERATURE_TARGET:PROCHOT_MIN</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: average</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: celsius</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-therm-status-resolution"><span class="pre">MSR::THERM_STATUS:RESOLUTION</span></code></dt><dd><p>The resolution of the sensor that measures <a class="reference internal" href="#msr-therm-status-digital-readout"><span class="std std-ref">MSR::THERM_STATUS:DIGITAL_READOUT</span></a> temperature.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: celsius</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-therm-status-reading-valid"><span class="pre">MSR::THERM_STATUS:READING_VALID</span></code></dt><dd><p>Indicates whether <a class="reference internal" href="#msr-therm-status-digital-readout"><span class="std std-ref">MSR::THERM_STATUS:DIGITAL_READOUT</span></a> contains a valid temperature readout. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-misc-enable-limit-cpuid-maxval"><span class="pre">MSR::MISC_ENABLE:LIMIT_CPUID_MAXVAL</span></code></dt><dd><p>Indicates whether the operating system does not support usage of the CPUID instruction with functions that require EAX values great than 2. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-package-therm-interrupt-thresh-1"><span class="pre">MSR::PACKAGE_THERM_INTERRUPT:THRESH_1</span></code></dt><dd><p>The temperature at or above which the <a class="reference internal" href="#msr-therm-status-thermal-thresh-1-status"><span class="std std-ref">MSR::THERM_STATUS:THERMAL_THRESH_1_STATUS</span></a> indicator is set, in degrees below <a class="reference internal" href="#msr-temperature-target-prochot-min"><span class="std std-ref">MSR::TEMPERATURE_TARGET:PROCHOT_MIN</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: celsius</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-package-therm-interrupt-thresh-2"><span class="pre">MSR::PACKAGE_THERM_INTERRUPT:THRESH_2</span></code></dt><dd><p>The temperature at or above which the <a class="reference internal" href="#msr-therm-status-thermal-thresh-2-status"><span class="std std-ref">MSR::THERM_STATUS:THERMAL_THRESH_2_STATUS</span></a> indicator is set, in degrees below <a class="reference internal" href="#msr-temperature-target-prochot-min"><span class="std std-ref">MSR::TEMPERATURE_TARGET:PROCHOT_MIN</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: celsius</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-package-therm-status-thermal-status-flag"><span class="pre">MSR::PACKAGE_THERM_STATUS:THERMAL_STATUS_FLAG</span></code></dt><dd><p>Indicates whether the package’s on-die sensor reads a high temperature (PROCHOT). When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-package-therm-status-prochot-event"><span class="pre">MSR::PACKAGE_THERM_STATUS:PROCHOT_EVENT</span></code></dt><dd><p>Indicates whether a package high temperature (PROCHOT) or forced power reduction (FORCEPR) is being externally asserted. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-package-therm-status-critical-temp-status"><span class="pre">MSR::PACKAGE_THERM_STATUS:CRITICAL_TEMP_STATUS</span></code></dt><dd><p>Indicates whether the package’s on-die sensor reads a critical temperature and the system cannot guarantee reliable operation. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-package-therm-status-thermal-thresh-1-status"><span class="pre">MSR::PACKAGE_THERM_STATUS:THERMAL_THRESH_1_STATUS</span></code></dt><dd><p>Indicates whether the package’s on-die sensor reads equal to or hotter than the threshold in <a class="reference internal" href="#msr-package-therm-interrupt-thresh-1"><span class="std std-ref">MSR::PACKAGE_THERM_INTERRUPT:THRESH_1</span></a>. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-package-therm-status-thermal-thresh-2-status"><span class="pre">MSR::PACKAGE_THERM_STATUS:THERMAL_THRESH_2_STATUS</span></code></dt><dd><p>Indicates whether the package’s on-die sensor reads equal to or hotter than the threshold in <a class="reference internal" href="#msr-package-therm-interrupt-thresh-2"><span class="std std-ref">MSR::PACKAGE_THERM_INTERRUPT:THRESH_2</span></a>. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-package-therm-status-power-limit-status"><span class="pre">MSR::PACKAGE_THERM_STATUS:POWER_LIMIT_STATUS</span></code></dt><dd><p>Indicates whether requested P-States or requested clock duty cycles are not met due to a package power limit. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-package-therm-status-digital-readout"><span class="pre">MSR::PACKAGE_THERM_STATUS:DIGITAL_READOUT</span></code></dt><dd><p>The temperature reading on this package’s on-die sensor, in degrees below <a class="reference internal" href="#msr-temperature-target-prochot-min"><span class="std std-ref">MSR::TEMPERATURE_TARGET:PROCHOT_MIN</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: average</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: celsius</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-pmc0-perfctr"><span class="pre">MSR::IA32_PMC0:PERFCTR</span></code></dt><dd><p>The count of events detected by MSR::IA32_PERFEVTSEL0.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-pmc1-perfctr"><span class="pre">MSR::IA32_PMC1:PERFCTR</span></code></dt><dd><p>The count of events detected by MSR::IA32_PERFEVTSEL1.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-pmc2-perfctr"><span class="pre">MSR::IA32_PMC2:PERFCTR</span></code></dt><dd><p>The count of events detected by MSR::IA32_PERFEVTSEL2.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-pmc3-perfctr"><span class="pre">MSR::IA32_PMC3:PERFCTR</span></code></dt><dd><p>The count of events detected by MSR::IA32_PERFEVTSEL3.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-fixed-ctr0-inst-retired-any"><span class="pre">MSR::FIXED_CTR0:INST_RETIRED_ANY</span></code></dt><dd><p>The count of the number of instructions executed. Requires geopmwrite -e.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-fixed-ctr1-cpu-clk-unhalted-thread"><span class="pre">MSR::FIXED_CTR1:CPU_CLK_UNHALTED_THREAD</span></code></dt><dd><p>The count of the number of cycles while the logical processor is not in a halt state.  The count rate may change based on core frequency.  Requires geopmwrite -e.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-fixed-ctr2-cpu-clk-unhalted-ref-tsc"><span class="pre">MSR::FIXED_CTR2:CPU_CLK_UNHALTED_REF_TSC</span></code></dt><dd><p>The count of the number of cycles while the logical processor is not in a halt state and not in a stop-clock state.  The count rate is fixed at the TIMESTAMP_COUNT rate.  Requires geopmwrite -e.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
</dl>
</section>
<section id="knights-landing-knl-signals">
<h3><a class="toc-backref" href="#id2" role="doc-backlink">Knights Landing (KNL) Signals</a><a class="headerlink" href="#knights-landing-knl-signals" title="Link to this heading"></a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate" id="msr-platform-info-max-non-turbo-ratio"><span class="pre">MSR::PLATFORM_INFO:MAX_NON_TURBO_RATIO</span></code></dt><dd><p>The processor’s maximum non-turbo frequency.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: average</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-platform-info-programmable-ratio-limits-turbo-mode"><span class="pre">MSR::PLATFORM_INFO:PROGRAMMABLE_RATIO_LIMITS_TURBO_MODE</span></code></dt><dd><p>Indicates whether the MSR::TURBO_RATIO_LIMIT:* signals are also available as controls. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-platform-info-programmable-tdp-limits-turbo-mode"><span class="pre">MSR::PLATFORM_INFO:PROGRAMMABLE_TDP_LIMITS_TURBO_MODE</span></code></dt><dd><p>Indicates whether this platform supports programmable TDP limits for turbo mode. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-platform-info-max-efficiency-ratio"><span class="pre">MSR::PLATFORM_INFO:MAX_EFFICIENCY_RATIO</span></code></dt><dd><p>The minimum operating frequency of the processor.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: average</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-perf-status-freq"><span class="pre">MSR::PERF_STATUS:FREQ</span></code></dt><dd><p>The current operating frequency of the CPU.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: average</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-temperature-target-prochot-min"><span class="pre">MSR::TEMPERATURE_TARGET:PROCHOT_MIN</span></code></dt><dd><p>The lowest temperature considered a high temperature. Measured temperatures at or above this value will generate a PROCHOT event.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: celsius</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-temperature-target-tcc-active-offset"><span class="pre">MSR::TEMPERATURE_TARGET:TCC_ACTIVE_OFFSET</span></code></dt><dd><p>An offset to subtract from <a class="reference internal" href="#msr-temperature-target-prochot-min"><span class="std std-ref">MSR::TEMPERATURE_TARGET:PROCHOT_MIN</span></a> as the cutoff to generate a PROCHOT event.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: celsius</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-group-0-max-cores"><span class="pre">MSR::TURBO_RATIO_LIMIT:GROUP_0_MAX_CORES</span></code></dt><dd><p>Defines the group 0 active core count, which is the number of active cores for a maximum turbo frequency of <a class="reference internal" href="#msr-turbo-ratio-limit-group-0-max-ratio-limit"><span class="std std-ref">MSR::TURBO_RATIO_LIMIT:GROUP_0_MAX_RATIO_LIMIT</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-group-0-max-ratio-limit"><span class="pre">MSR::TURBO_RATIO_LIMIT:GROUP_0_MAX_RATIO_LIMIT</span></code></dt><dd><p>Maximum turbo frequency with up to the group 0 active core count.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-group-1-incremental-cores"><span class="pre">MSR::TURBO_RATIO_LIMIT:GROUP_1_INCREMENTAL_CORES</span></code></dt><dd><p>Additional active cores to define the group 1 active core count, beyond the group 0 active core count.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-group-1-ratio-limit-delta"><span class="pre">MSR::TURBO_RATIO_LIMIT:GROUP_1_RATIO_LIMIT_DELTA</span></code></dt><dd><p>Drop in maximum turbo frequency for the group 1 active core count, relative to the group 0 maximum turbo frequency.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-group-2-incremental-cores"><span class="pre">MSR::TURBO_RATIO_LIMIT:GROUP_2_INCREMENTAL_CORES</span></code></dt><dd><p>Additional active cores to define the group 2 active core count, beyond the group 1 active core count.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-group-2-ratio-limit-delta"><span class="pre">MSR::TURBO_RATIO_LIMIT:GROUP_2_RATIO_LIMIT_DELTA</span></code></dt><dd><p>Drop in maximum turbo frequency for the group 2 active core count, relative to the group 1 maximum turbo frequency.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-group-3-incremental-cores"><span class="pre">MSR::TURBO_RATIO_LIMIT:GROUP_3_INCREMENTAL_CORES</span></code></dt><dd><p>Additional active cores to define the group 3 active core count, beyond the group 2 active core count.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-group-3-ratio-limit-delta"><span class="pre">MSR::TURBO_RATIO_LIMIT:GROUP_3_RATIO_LIMIT_DELTA</span></code></dt><dd><p>Drop in maximum turbo frequency for the group 3 active core count, relative to the group 2 maximum turbo frequency.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-group-4-incremental-cores"><span class="pre">MSR::TURBO_RATIO_LIMIT:GROUP_4_INCREMENTAL_CORES</span></code></dt><dd><p>Additional active cores to define the group 4 active core count, beyond the group 3 active core count.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-group-4-ratio-limit-delta"><span class="pre">MSR::TURBO_RATIO_LIMIT:GROUP_4_RATIO_LIMIT_DELTA</span></code></dt><dd><p>Drop in maximum turbo frequency for the group 4 active core count, relative to the group 3 maximum turbo frequency.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-group-5-incremental-cores"><span class="pre">MSR::TURBO_RATIO_LIMIT:GROUP_5_INCREMENTAL_CORES</span></code></dt><dd><p>Additional active cores to define the group 5 active core count, beyond the group 4 active core count.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-group-5-ratio-limit-delta"><span class="pre">MSR::TURBO_RATIO_LIMIT:GROUP_5_RATIO_LIMIT_DELTA</span></code></dt><dd><p>Drop in maximum turbo frequency for the group 5 active core count, relative to the group 4 maximum turbo frequency.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-group-6-incremental-cores"><span class="pre">MSR::TURBO_RATIO_LIMIT:GROUP_6_INCREMENTAL_CORES</span></code></dt><dd><p>Additional active cores to define the group 6 active core count, beyond the group 5 active core count.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-group-6-ratio-limit-delta"><span class="pre">MSR::TURBO_RATIO_LIMIT:GROUP_6_RATIO_LIMIT_DELTA</span></code></dt><dd><p>Drop in maximum turbo frequency for the group 6 active core count, relative to the group 5 maximum turbo frequency.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-rapl-power-unit-power"><span class="pre">MSR::RAPL_POWER_UNIT:POWER</span></code></dt><dd><p>The resolution of RAPL power interfaces.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-rapl-power-unit-energy"><span class="pre">MSR::RAPL_POWER_UNIT:ENERGY</span></code></dt><dd><p>The resolution of RAPL energy interfaces.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: joules</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-rapl-power-unit-time"><span class="pre">MSR::RAPL_POWER_UNIT:TIME</span></code></dt><dd><p>The resolution of RAPL time interfaces.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-lock"><span class="pre">MSR::PKG_POWER_LIMIT:LOCK</span></code></dt><dd><p>Ignore any changes to PL1 and PL2 configuration in PKG_POWER_LIMIT until the next reset.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-energy-status-energy"><span class="pre">MSR::PKG_ENERGY_STATUS:ENERGY</span></code></dt><dd><p>An increasing meter of energy consumed by the package over time.  It will reset periodically due to roll-over.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: joules</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-info-thermal-spec-power"><span class="pre">MSR::PKG_POWER_INFO:THERMAL_SPEC_POWER</span></code></dt><dd><p>Maximum power to stay within the thermal limits based on the design (TDP).</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-info-min-power"><span class="pre">MSR::PKG_POWER_INFO:MIN_POWER</span></code></dt><dd><p>The minimum power limit based on the electrical specification.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-info-max-power"><span class="pre">MSR::PKG_POWER_INFO:MAX_POWER</span></code></dt><dd><p>The maximum power limit based on the electrical specification.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-info-max-time-window"><span class="pre">MSR::PKG_POWER_INFO:MAX_TIME_WINDOW</span></code></dt><dd><p>The maximum time accepted in <a class="reference internal" href="#msr-pkg-power-limit-pl1-time-window"><span class="std std-ref">MSR::PKG_POWER_LIMIT:PL1_TIME_WINDOW</span></a> and <a class="reference internal" href="#msr-pkg-power-limit-pl2-time-window"><span class="std std-ref">MSR::PKG_POWER_LIMIT:PL2_TIME_WINDOW</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-energy-status-energy"><span class="pre">MSR::DRAM_ENERGY_STATUS:ENERGY</span></code></dt><dd><p>An increasing meter of energy consumed by the DRAM over time.  It will reset periodically due to roll-over.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: joules</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-perf-status-throttle-time"><span class="pre">MSR::DRAM_PERF_STATUS:THROTTLE_TIME</span></code></dt><dd><p>The amount of time that the package was throttled below the requested frequency due to <a class="reference internal" href="#msr-dram-power-limit-power-limit"><span class="std std-ref">MSR::DRAM_POWER_LIMIT:POWER_LIMIT</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-info-thermal-spec-power"><span class="pre">MSR::DRAM_POWER_INFO:THERMAL_SPEC_POWER</span></code></dt><dd><p>Maximum DRAM power to stay within the thermal limits based on the design.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-info-min-power"><span class="pre">MSR::DRAM_POWER_INFO:MIN_POWER</span></code></dt><dd><p>The minimum DRAM power limit based on the electrical specification.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-info-max-power"><span class="pre">MSR::DRAM_POWER_INFO:MAX_POWER</span></code></dt><dd><p>The maximum DRAM power limit based on the electrical specification.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-info-max-time-window"><span class="pre">MSR::DRAM_POWER_INFO:MAX_TIME_WINDOW</span></code></dt><dd><p>The maximum value accepted in <a class="reference internal" href="#msr-dram-power-limit-time-window"><span class="std std-ref">MSR::DRAM_POWER_LIMIT:TIME_WINDOW</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-uncore-perf-status-freq"><span class="pre">MSR::UNCORE_PERF_STATUS:FREQ</span></code></dt><dd><p>The current uncore frequency.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: average</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
</dl>
</section>
<section id="sandy-bridge-snb-signals">
<h3><a class="toc-backref" href="#id3" role="doc-backlink">Sandy Bridge (SNB) Signals</a><a class="headerlink" href="#sandy-bridge-snb-signals" title="Link to this heading"></a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate" id="msr-platform-info-max-non-turbo-ratio"><span class="pre">MSR::PLATFORM_INFO:MAX_NON_TURBO_RATIO</span></code></dt><dd><p>The processor’s maximum non-turbo frequency.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-platform-info-programmable-ratio-limits-turbo-mode"><span class="pre">MSR::PLATFORM_INFO:PROGRAMMABLE_RATIO_LIMITS_TURBO_MODE</span></code></dt><dd><p>Indicates whether the MSR::TURBO_RATIO_LIMIT:* signals are also available as controls.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-platform-info-programmable-tdp-limits-turbo-mode"><span class="pre">MSR::PLATFORM_INFO:PROGRAMMABLE_TDP_LIMITS_TURBO_MODE</span></code></dt><dd><p>Indicates whether this platform supports programmable TDP limits for turbo mode.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-platform-info-max-efficiency-ratio"><span class="pre">MSR::PLATFORM_INFO:MAX_EFFICIENCY_RATIO</span></code></dt><dd><p>The minimum operating frequency of the processor.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-perf-status-freq"><span class="pre">MSR::PERF_STATUS:FREQ</span></code></dt><dd><p>The current operating frequency of the CPU.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: average</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-temperature-target-prochot-min"><span class="pre">MSR::TEMPERATURE_TARGET:PROCHOT_MIN</span></code></dt><dd><p>The lowest temperature considered a high temperature. Measured temperatures at or above this value will generate a PROCHOT event.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: celsius</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-max-ratio-limit-1core"><span class="pre">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_1CORE</span></code></dt><dd><p>Maximum turbo frequency with up to 1 active core.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-max-ratio-limit-2cores"><span class="pre">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_2CORES</span></code></dt><dd><p>Maximum turbo frequency with up to 2 active cores.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-max-ratio-limit-3cores"><span class="pre">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_3CORES</span></code></dt><dd><p>Maximum turbo frequency with up to 3 active cores.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-max-ratio-limit-4cores"><span class="pre">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_4CORES</span></code></dt><dd><p>Maximum turbo frequency with up to 4 active cores.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-max-ratio-limit-5cores"><span class="pre">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_5CORES</span></code></dt><dd><p>Maximum turbo frequency with up to 5 active cores.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-max-ratio-limit-6cores"><span class="pre">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_6CORES</span></code></dt><dd><p>Maximum turbo frequency with up to 6 active cores.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-max-ratio-limit-7cores"><span class="pre">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_7CORES</span></code></dt><dd><p>Maximum turbo frequency with up to 7 active cores.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-max-ratio-limit-8cores"><span class="pre">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_8CORES</span></code></dt><dd><p>Maximum turbo frequency with up to 8 active cores.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-rapl-power-unit-power"><span class="pre">MSR::RAPL_POWER_UNIT:POWER</span></code></dt><dd><p>The resolution of RAPL power interfaces.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-rapl-power-unit-energy"><span class="pre">MSR::RAPL_POWER_UNIT:ENERGY</span></code></dt><dd><p>The resolution of RAPL energy interfaces.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: joules</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-rapl-power-unit-time"><span class="pre">MSR::RAPL_POWER_UNIT:TIME</span></code></dt><dd><p>The resolution of RAPL time interfaces.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-lock"><span class="pre">MSR::PKG_POWER_LIMIT:LOCK</span></code></dt><dd><p>Ignore any changes to PL1 and PL2 configuration in PKG_POWER_LIMIT until the next reset.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-energy-status-energy"><span class="pre">MSR::PKG_ENERGY_STATUS:ENERGY</span></code></dt><dd><p>An increasing meter of energy consumed by the package over time.  It will reset periodically due to roll-over.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: joules</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-info-thermal-spec-power"><span class="pre">MSR::PKG_POWER_INFO:THERMAL_SPEC_POWER</span></code></dt><dd><p>Maximum power to stay within the thermal limits based on the design (TDP).</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-info-min-power"><span class="pre">MSR::PKG_POWER_INFO:MIN_POWER</span></code></dt><dd><p>The minimum power limit based on the electrical specification.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-info-max-power"><span class="pre">MSR::PKG_POWER_INFO:MAX_POWER</span></code></dt><dd><p>The maximum power limit based on the electrical specification.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-info-max-time-window"><span class="pre">MSR::PKG_POWER_INFO:MAX_TIME_WINDOW</span></code></dt><dd><p>The maximum time accepted in <a class="reference internal" href="#msr-pkg-power-limit-pl1-time-window"><span class="std std-ref">MSR::PKG_POWER_LIMIT:PL1_TIME_WINDOW</span></a> and <a class="reference internal" href="#msr-pkg-power-limit-pl2-time-window"><span class="std std-ref">MSR::PKG_POWER_LIMIT:PL2_TIME_WINDOW</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-limit-lock"><span class="pre">MSR::DRAM_POWER_LIMIT:LOCK</span></code></dt><dd><p>Ignore any changes to configuration in DRAM_POWER_LIMIT until the next reset.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-energy-status-energy"><span class="pre">MSR::DRAM_ENERGY_STATUS:ENERGY</span></code></dt><dd><p>An increasing meter of energy consumed by the DRAM over time.  It will reset periodically due to roll-over.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: joules</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-perf-status-throttle-time"><span class="pre">MSR::DRAM_PERF_STATUS:THROTTLE_TIME</span></code></dt><dd><p>The amount of time that the package was throttled below the requested frequency due to <a class="reference internal" href="#msr-dram-power-limit-power-limit"><span class="std std-ref">MSR::DRAM_POWER_LIMIT:POWER_LIMIT</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-info-thermal-spec-power"><span class="pre">MSR::DRAM_POWER_INFO:THERMAL_SPEC_POWER</span></code></dt><dd><p>Maximum DRAM power to stay within the thermal limits based on the design.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-info-min-power"><span class="pre">MSR::DRAM_POWER_INFO:MIN_POWER</span></code></dt><dd><p>The minimum DRAM power limit based on the electrical specification.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-info-max-power"><span class="pre">MSR::DRAM_POWER_INFO:MAX_POWER</span></code></dt><dd><p>The maximum DRAM power limit based on the electrical specification.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-info-max-time-window"><span class="pre">MSR::DRAM_POWER_INFO:MAX_TIME_WINDOW</span></code></dt><dd><p>The maximum value accepted in <a class="reference internal" href="#msr-dram-power-limit-time-window"><span class="std std-ref">MSR::DRAM_POWER_LIMIT:TIME_WINDOW</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
</dl>
</section>
<section id="haswell-hsx-signals">
<h3><a class="toc-backref" href="#id4" role="doc-backlink">Haswell (HSX) Signals</a><a class="headerlink" href="#haswell-hsx-signals" title="Link to this heading"></a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate" id="msr-platform-info-max-non-turbo-ratio"><span class="pre">MSR::PLATFORM_INFO:MAX_NON_TURBO_RATIO</span></code></dt><dd><p>The processor’s maximum non-turbo frequency.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-platform-info-programmable-ratio-limits-turbo-mode"><span class="pre">MSR::PLATFORM_INFO:PROGRAMMABLE_RATIO_LIMITS_TURBO_MODE</span></code></dt><dd><p>Indicates whether the MSR::TURBO_RATIO_LIMIT:* signals are also available as controls.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-platform-info-programmable-tdp-limits-turbo-mode"><span class="pre">MSR::PLATFORM_INFO:PROGRAMMABLE_TDP_LIMITS_TURBO_MODE</span></code></dt><dd><p>Indicates whether this platform supports programmable TDP limits for turbo mode.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-platform-info-programmable-tcc-activation-offset"><span class="pre">MSR::PLATFORM_INFO:PROGRAMMABLE_TCC_ACTIVATION_OFFSET</span></code></dt><dd><p>Indicates whether the platform permits writes to <a class="reference internal" href="#msr-temperature-target-tcc-active-offset"><span class="std std-ref">MSR::TEMPERATURE_TARGET:TCC_ACTIVE_OFFSET</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-platform-info-max-efficiency-ratio"><span class="pre">MSR::PLATFORM_INFO:MAX_EFFICIENCY_RATIO</span></code></dt><dd><p>The minimum operating frequency of the processor.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-perf-status-freq"><span class="pre">MSR::PERF_STATUS:FREQ</span></code></dt><dd><p>The current operating frequency of the CPU.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: average</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-temperature-target-prochot-min"><span class="pre">MSR::TEMPERATURE_TARGET:PROCHOT_MIN</span></code></dt><dd><p>The lowest temperature considered a high temperature. Measured temperatures at or above this value will generate a PROCHOT event.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: celsius</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-temperature-target-tcc-active-offset"><span class="pre">MSR::TEMPERATURE_TARGET:TCC_ACTIVE_OFFSET</span></code></dt><dd><p>An offset to subtract from <a class="reference internal" href="#msr-temperature-target-prochot-min"><span class="std std-ref">MSR::TEMPERATURE_TARGET:PROCHOT_MIN</span></a> as the cutoff to generate a PROCHOT event.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: celsius</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-max-ratio-limit-1core"><span class="pre">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_1CORE</span></code></dt><dd><p>Maximum turbo frequency when 1 core is active.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-max-ratio-limit-2cores"><span class="pre">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_2CORES</span></code></dt><dd><p>Maximum turbo frequency when 2 cores are active.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-max-ratio-limit-3cores"><span class="pre">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_3CORES</span></code></dt><dd><p>Maximum turbo frequency when 3 cores are active.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-max-ratio-limit-4cores"><span class="pre">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_4CORES</span></code></dt><dd><p>Maximum turbo frequency when 4 cores are active.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-max-ratio-limit-5cores"><span class="pre">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_5CORES</span></code></dt><dd><p>Maximum turbo frequency when 5 cores are active.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-max-ratio-limit-6cores"><span class="pre">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_6CORES</span></code></dt><dd><p>Maximum turbo frequency when 6 cores are active.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-max-ratio-limit-7cores"><span class="pre">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_7CORES</span></code></dt><dd><p>Maximum turbo frequency when 7 cores are active.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-max-ratio-limit-8cores"><span class="pre">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_8CORES</span></code></dt><dd><p>Maximum turbo frequency when 8 cores are active.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit1-max-ratio-limit-9cores"><span class="pre">MSR::TURBO_RATIO_LIMIT1:MAX_RATIO_LIMIT_9CORES</span></code></dt><dd><p>Maximum turbo frequency when 9 cores are active.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit1-max-ratio-limit-10cores"><span class="pre">MSR::TURBO_RATIO_LIMIT1:MAX_RATIO_LIMIT_10CORES</span></code></dt><dd><p>Maximum turbo frequency when 10 cores are active.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit1-max-ratio-limit-11cores"><span class="pre">MSR::TURBO_RATIO_LIMIT1:MAX_RATIO_LIMIT_11CORES</span></code></dt><dd><p>Maximum turbo frequency when 11 cores are active.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit1-max-ratio-limit-12cores"><span class="pre">MSR::TURBO_RATIO_LIMIT1:MAX_RATIO_LIMIT_12CORES</span></code></dt><dd><p>Maximum turbo frequency when 12 cores are active.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit1-max-ratio-limit-13cores"><span class="pre">MSR::TURBO_RATIO_LIMIT1:MAX_RATIO_LIMIT_13CORES</span></code></dt><dd><p>Maximum turbo frequency when 13 cores are active.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit1-max-ratio-limit-14cores"><span class="pre">MSR::TURBO_RATIO_LIMIT1:MAX_RATIO_LIMIT_14CORES</span></code></dt><dd><p>Maximum turbo frequency when 14 cores are active.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit1-max-ratio-limit-15cores"><span class="pre">MSR::TURBO_RATIO_LIMIT1:MAX_RATIO_LIMIT_15CORES</span></code></dt><dd><p>Maximum turbo frequency when 15 cores are active.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit1-max-ratio-limit-16cores"><span class="pre">MSR::TURBO_RATIO_LIMIT1:MAX_RATIO_LIMIT_16CORES</span></code></dt><dd><p>Maximum turbo frequency when 16 cores are active.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit2-max-ratio-limit-17cores"><span class="pre">MSR::TURBO_RATIO_LIMIT2:MAX_RATIO_LIMIT_17CORES</span></code></dt><dd><p>Maximum turbo frequency when 17 cores are active.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit2-max-ratio-limit-18cores"><span class="pre">MSR::TURBO_RATIO_LIMIT2:MAX_RATIO_LIMIT_18CORES</span></code></dt><dd><p>Maximum turbo frequency when 18 cores are active.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-rapl-power-unit-power"><span class="pre">MSR::RAPL_POWER_UNIT:POWER</span></code></dt><dd><p>The resolution of RAPL power interfaces.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-rapl-power-unit-energy"><span class="pre">MSR::RAPL_POWER_UNIT:ENERGY</span></code></dt><dd><p>The resolution of RAPL energy interfaces.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: joules</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-rapl-power-unit-time"><span class="pre">MSR::RAPL_POWER_UNIT:TIME</span></code></dt><dd><p>The resolution of RAPL time interfaces.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-lock"><span class="pre">MSR::PKG_POWER_LIMIT:LOCK</span></code></dt><dd><p>Ignore any changes to PL1 and PL2 configuration in PKG_POWER_LIMIT until the next reset.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-energy-status-energy"><span class="pre">MSR::PKG_ENERGY_STATUS:ENERGY</span></code></dt><dd><p>An increasing meter of energy consumed by the package over time.  It will reset periodically due to roll-over.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: joules</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-info-thermal-spec-power"><span class="pre">MSR::PKG_POWER_INFO:THERMAL_SPEC_POWER</span></code></dt><dd><p>Maximum power to stay within the thermal limits based on the design (TDP).</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-info-min-power"><span class="pre">MSR::PKG_POWER_INFO:MIN_POWER</span></code></dt><dd><p>The minimum power limit based on the electrical specification.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-info-max-power"><span class="pre">MSR::PKG_POWER_INFO:MAX_POWER</span></code></dt><dd><p>The maximum power limit based on the electrical specification.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-info-max-time-window"><span class="pre">MSR::PKG_POWER_INFO:MAX_TIME_WINDOW</span></code></dt><dd><p>The maximum time accepted in <a class="reference internal" href="#msr-pkg-power-limit-pl1-time-window"><span class="std std-ref">MSR::PKG_POWER_LIMIT:PL1_TIME_WINDOW</span></a> and <a class="reference internal" href="#msr-pkg-power-limit-pl2-time-window"><span class="std std-ref">MSR::PKG_POWER_LIMIT:PL2_TIME_WINDOW</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-limit-lock"><span class="pre">MSR::DRAM_POWER_LIMIT:LOCK</span></code></dt><dd><p>Ignore any changes to configuration in DRAM_POWER_LIMIT until the next reset.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-energy-status-energy"><span class="pre">MSR::DRAM_ENERGY_STATUS:ENERGY</span></code></dt><dd><p>An increasing meter of energy consumed by the DRAM over time.  It will reset periodically due to roll-over.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: joules</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-perf-status-throttle-time"><span class="pre">MSR::DRAM_PERF_STATUS:THROTTLE_TIME</span></code></dt><dd><p>The amount of time that the package was throttled below the requested frequency due to <a class="reference internal" href="#msr-dram-power-limit-power-limit"><span class="std std-ref">MSR::DRAM_POWER_LIMIT:POWER_LIMIT</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-info-thermal-spec-power"><span class="pre">MSR::DRAM_POWER_INFO:THERMAL_SPEC_POWER</span></code></dt><dd><p>Maximum DRAM power to stay within the thermal limits based on the design.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-info-min-power"><span class="pre">MSR::DRAM_POWER_INFO:MIN_POWER</span></code></dt><dd><p>The minimum DRAM power limit based on the electrical specification.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-info-max-power"><span class="pre">MSR::DRAM_POWER_INFO:MAX_POWER</span></code></dt><dd><p>The maximum DRAM power limit based on the electrical specification.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-info-max-time-window"><span class="pre">MSR::DRAM_POWER_INFO:MAX_TIME_WINDOW</span></code></dt><dd><p>The maximum value accepted in <a class="reference internal" href="#msr-dram-power-limit-time-window"><span class="std std-ref">MSR::DRAM_POWER_LIMIT:TIME_WINDOW</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-uncore-perf-status-freq"><span class="pre">MSR::UNCORE_PERF_STATUS:FREQ</span></code></dt><dd><p>The current uncore frequency.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: average</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
</dl>
</section>
<section id="skylake-skx-signals">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">Skylake (SKX) Signals</a><a class="headerlink" href="#skylake-skx-signals" title="Link to this heading"></a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate" id="msr-platform-info-max-non-turbo-ratio"><span class="pre">MSR::PLATFORM_INFO:MAX_NON_TURBO_RATIO</span></code></dt><dd><p>The processor’s maximum non-turbo frequency.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-platform-info-programmable-ratio-limits-turbo-mode"><span class="pre">MSR::PLATFORM_INFO:PROGRAMMABLE_RATIO_LIMITS_TURBO_MODE</span></code></dt><dd><p>Indicates whether the MSR::TURBO_RATIO_LIMIT:* signals are also available as controls.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-platform-info-programmable-tdp-limits-turbo-mode"><span class="pre">MSR::PLATFORM_INFO:PROGRAMMABLE_TDP_LIMITS_TURBO_MODE</span></code></dt><dd><p>Indicates whether this platform supports programmable TDP limits for turbo mode.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-platform-info-programmable-tcc-activation-offset"><span class="pre">MSR::PLATFORM_INFO:PROGRAMMABLE_TCC_ACTIVATION_OFFSET</span></code></dt><dd><p>Indicates whether the platform permits writes to <a class="reference internal" href="#msr-temperature-target-tcc-active-offset"><span class="std std-ref">MSR::TEMPERATURE_TARGET:TCC_ACTIVE_OFFSET</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-platform-info-max-efficiency-ratio"><span class="pre">MSR::PLATFORM_INFO:MAX_EFFICIENCY_RATIO</span></code></dt><dd><p>The minimum operating frequency of the processor.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-perf-status-freq"><span class="pre">MSR::PERF_STATUS:FREQ</span></code></dt><dd><p>The current operating frequency of the CPU.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: average</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-temperature-target-prochot-min"><span class="pre">MSR::TEMPERATURE_TARGET:PROCHOT_MIN</span></code></dt><dd><p>The lowest temperature considered a high temperature. Measured temperatures at or above this value will generate a PROCHOT event.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: celsius</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-temperature-target-tcc-active-offset"><span class="pre">MSR::TEMPERATURE_TARGET:TCC_ACTIVE_OFFSET</span></code></dt><dd><p>An offset to subtract from <a class="reference internal" href="#msr-temperature-target-prochot-min"><span class="std std-ref">MSR::TEMPERATURE_TARGET:PROCHOT_MIN</span></a> as the cutoff to generate a PROCHOT event.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: celsius</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-max-ratio-limit-0"><span class="pre">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_0</span></code></dt><dd><p>Maximum turbo frequency with up to <a class="reference internal" href="#msr-turbo-ratio-limit-cores-numcore-0"><span class="std std-ref">MSR::TURBO_RATIO_LIMIT_CORES:NUMCORE_0</span></a> active cores.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-max-ratio-limit-1"><span class="pre">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_1</span></code></dt><dd><p>Maximum turbo frequency with more than <a class="reference internal" href="#msr-turbo-ratio-limit-cores-numcore-0"><span class="std std-ref">MSR::TURBO_RATIO_LIMIT_CORES:NUMCORE_0</span></a> and up to <a class="reference internal" href="#msr-turbo-ratio-limit-cores-numcore-1"><span class="std std-ref">MSR::TURBO_RATIO_LIMIT_CORES:NUMCORE_1</span></a> active cores.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-max-ratio-limit-2"><span class="pre">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_2</span></code></dt><dd><p>Maximum turbo frequency with more than <a class="reference internal" href="#msr-turbo-ratio-limit-cores-numcore-1"><span class="std std-ref">MSR::TURBO_RATIO_LIMIT_CORES:NUMCORE_1</span></a> and up to <a class="reference internal" href="#msr-turbo-ratio-limit-cores-numcore-2"><span class="std std-ref">MSR::TURBO_RATIO_LIMIT_CORES:NUMCORE_2</span></a> active cores.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-max-ratio-limit-3"><span class="pre">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_3</span></code></dt><dd><p>Maximum turbo frequency with more than <a class="reference internal" href="#msr-turbo-ratio-limit-cores-numcore-2"><span class="std std-ref">MSR::TURBO_RATIO_LIMIT_CORES:NUMCORE_2</span></a> and up to <a class="reference internal" href="#msr-turbo-ratio-limit-cores-numcore-3"><span class="std std-ref">MSR::TURBO_RATIO_LIMIT_CORES:NUMCORE_3</span></a> active cores.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-max-ratio-limit-4"><span class="pre">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_4</span></code></dt><dd><p>Maximum turbo frequency with more than <a class="reference internal" href="#msr-turbo-ratio-limit-cores-numcore-3"><span class="std std-ref">MSR::TURBO_RATIO_LIMIT_CORES:NUMCORE_3</span></a> and up to <a class="reference internal" href="#msr-turbo-ratio-limit-cores-numcore-4"><span class="std std-ref">MSR::TURBO_RATIO_LIMIT_CORES:NUMCORE_4</span></a> active cores.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-max-ratio-limit-5"><span class="pre">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_5</span></code></dt><dd><p>Maximum turbo frequency with more than <a class="reference internal" href="#msr-turbo-ratio-limit-cores-numcore-4"><span class="std std-ref">MSR::TURBO_RATIO_LIMIT_CORES:NUMCORE_4</span></a> and up to <a class="reference internal" href="#msr-turbo-ratio-limit-cores-numcore-5"><span class="std std-ref">MSR::TURBO_RATIO_LIMIT_CORES:NUMCORE_5</span></a> active cores.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-max-ratio-limit-6"><span class="pre">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_6</span></code></dt><dd><p>Maximum turbo frequency with more than <a class="reference internal" href="#msr-turbo-ratio-limit-cores-numcore-5"><span class="std std-ref">MSR::TURBO_RATIO_LIMIT_CORES:NUMCORE_5</span></a> and up to <a class="reference internal" href="#msr-turbo-ratio-limit-cores-numcore-6"><span class="std std-ref">MSR::TURBO_RATIO_LIMIT_CORES:NUMCORE_6</span></a> active cores.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-max-ratio-limit-7"><span class="pre">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_7</span></code></dt><dd><p>Maximum turbo frequency with more than <a class="reference internal" href="#msr-turbo-ratio-limit-cores-numcore-6"><span class="std std-ref">MSR::TURBO_RATIO_LIMIT_CORES:NUMCORE_6</span></a> and up to <a class="reference internal" href="#msr-turbo-ratio-limit-cores-numcore-7"><span class="std std-ref">MSR::TURBO_RATIO_LIMIT_CORES:NUMCORE_7</span></a> active cores.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-cores-numcore-0"><span class="pre">MSR::TURBO_RATIO_LIMIT_CORES:NUMCORE_0</span></code></dt><dd><p>Maximum number of active cores for a maximum turbo frequency of <a class="reference internal" href="#msr-turbo-ratio-limit-max-ratio-limit-0"><span class="std std-ref">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_0</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-cores-numcore-1"><span class="pre">MSR::TURBO_RATIO_LIMIT_CORES:NUMCORE_1</span></code></dt><dd><p>Maximum number of active cores for a maximum turbo frequency of <a class="reference internal" href="#msr-turbo-ratio-limit-max-ratio-limit-1"><span class="std std-ref">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_1</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-cores-numcore-2"><span class="pre">MSR::TURBO_RATIO_LIMIT_CORES:NUMCORE_2</span></code></dt><dd><p>Maximum number of active cores for a maximum turbo frequency of <a class="reference internal" href="#msr-turbo-ratio-limit-max-ratio-limit-2"><span class="std std-ref">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_2</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-cores-numcore-3"><span class="pre">MSR::TURBO_RATIO_LIMIT_CORES:NUMCORE_3</span></code></dt><dd><p>Maximum number of active cores for a maximum turbo frequency of <a class="reference internal" href="#msr-turbo-ratio-limit-max-ratio-limit-3"><span class="std std-ref">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_3</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-cores-numcore-4"><span class="pre">MSR::TURBO_RATIO_LIMIT_CORES:NUMCORE_4</span></code></dt><dd><p>Maximum number of active cores for a maximum turbo frequency of <a class="reference internal" href="#msr-turbo-ratio-limit-max-ratio-limit-4"><span class="std std-ref">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_4</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-cores-numcore-5"><span class="pre">MSR::TURBO_RATIO_LIMIT_CORES:NUMCORE_5</span></code></dt><dd><p>Maximum number of active cores for a maximum turbo frequency of <a class="reference internal" href="#msr-turbo-ratio-limit-max-ratio-limit-5"><span class="std std-ref">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_5</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-cores-numcore-6"><span class="pre">MSR::TURBO_RATIO_LIMIT_CORES:NUMCORE_6</span></code></dt><dd><p>Maximum number of active cores for a maximum turbo frequency of <a class="reference internal" href="#msr-turbo-ratio-limit-max-ratio-limit-6"><span class="std std-ref">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_6</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit-cores-numcore-7"><span class="pre">MSR::TURBO_RATIO_LIMIT_CORES:NUMCORE_7</span></code></dt><dd><p>Maximum number of active cores for a maximum turbo frequency of <a class="reference internal" href="#msr-turbo-ratio-limit-max-ratio-limit-7"><span class="std std-ref">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_7</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-rapl-power-unit-power"><span class="pre">MSR::RAPL_POWER_UNIT:POWER</span></code></dt><dd><p>The resolution of RAPL power interfaces.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-rapl-power-unit-energy"><span class="pre">MSR::RAPL_POWER_UNIT:ENERGY</span></code></dt><dd><p>The resolution of RAPL energy interfaces.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: joules</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-rapl-power-unit-time"><span class="pre">MSR::RAPL_POWER_UNIT:TIME</span></code></dt><dd><p>The resolution of RAPL time interfaces.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-lock"><span class="pre">MSR::PKG_POWER_LIMIT:LOCK</span></code></dt><dd><p>Ignore any changes to PL1 and PL2 configuration in PKG_POWER_LIMIT until the next reset.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-energy-status-energy"><span class="pre">MSR::PKG_ENERGY_STATUS:ENERGY</span></code></dt><dd><p>An increasing meter of energy consumed by the package over time.  It will reset periodically due to roll-over.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: joules</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-info-thermal-spec-power"><span class="pre">MSR::PKG_POWER_INFO:THERMAL_SPEC_POWER</span></code></dt><dd><p>Maximum power to stay within the thermal limits based on the design (TDP).</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-info-min-power"><span class="pre">MSR::PKG_POWER_INFO:MIN_POWER</span></code></dt><dd><p>The minimum power limit based on the electrical specification.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-info-max-power"><span class="pre">MSR::PKG_POWER_INFO:MAX_POWER</span></code></dt><dd><p>The maximum power limit based on the electrical specification.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-info-max-time-window"><span class="pre">MSR::PKG_POWER_INFO:MAX_TIME_WINDOW</span></code></dt><dd><p>The maximum time accepted in <a class="reference internal" href="#msr-pkg-power-limit-pl1-time-window"><span class="std std-ref">MSR::PKG_POWER_LIMIT:PL1_TIME_WINDOW</span></a> and <a class="reference internal" href="#msr-pkg-power-limit-pl2-time-window"><span class="std std-ref">MSR::PKG_POWER_LIMIT:PL2_TIME_WINDOW</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-limit-lock"><span class="pre">MSR::DRAM_POWER_LIMIT:LOCK</span></code></dt><dd><p>Ignore any changes to configuration in DRAM_POWER_LIMIT until the next reset.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-energy-status-energy"><span class="pre">MSR::DRAM_ENERGY_STATUS:ENERGY</span></code></dt><dd><p>An increasing meter of energy consumed by the DRAM over time.  It will reset periodically due to roll-over.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: joules</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-perf-status-throttle-time"><span class="pre">MSR::DRAM_PERF_STATUS:THROTTLE_TIME</span></code></dt><dd><p>The amount of time that the package was throttled below the requested frequency due to <a class="reference internal" href="#msr-dram-power-limit-power-limit"><span class="std std-ref">MSR::DRAM_POWER_LIMIT:POWER_LIMIT</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-info-thermal-spec-power"><span class="pre">MSR::DRAM_POWER_INFO:THERMAL_SPEC_POWER</span></code></dt><dd><p>Maximum DRAM power to stay within the thermal limits based on the design.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-info-min-power"><span class="pre">MSR::DRAM_POWER_INFO:MIN_POWER</span></code></dt><dd><p>The minimum DRAM power limit based on the electrical specification.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-info-max-power"><span class="pre">MSR::DRAM_POWER_INFO:MAX_POWER</span></code></dt><dd><p>The maximum DRAM power limit based on the electrical specification.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-info-max-time-window"><span class="pre">MSR::DRAM_POWER_INFO:MAX_TIME_WINDOW</span></code></dt><dd><p>The maximum value accepted in <a class="reference internal" href="#msr-dram-power-limit-time-window"><span class="std std-ref">MSR::DRAM_POWER_LIMIT:TIME_WINDOW</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pperf-pcnt"><span class="pre">MSR::PPERF:PCNT</span></code></dt><dd><p>A filtered counter of <a class="reference internal" href="#msr-aperf-acnt"><span class="std std-ref">MSR::APERF:ACNT</span></a> that only increments for cycles the hardware expects are productive toward instruction execution. This counter cannot measure processor performance when the CPU is inactive.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-qm-ctr-rm-data"><span class="pre">MSR::QM_CTR:RM_DATA</span></code></dt><dd><p>The raw counted value for the MSR::QM_EVTSEL:* configuration. Configurations that report bandwidth metrics report a raw value based on an implementation-specific counter. If reading a bandwidth metric, read the QM_CTR_SCALED alias instead.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-qm-ctr-unavailable"><span class="pre">MSR::QM_CTR:UNAVAILABLE</span></code></dt><dd><p>Indicates that no monitoring data is available, and <a class="reference internal" href="#msr-qm-ctr-rm-data"><span class="std std-ref">MSR::QM_CTR:RM_DATA</span></a> does not contain valid data. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-qm-ctr-error"><span class="pre">MSR::QM_CTR:ERROR</span></code></dt><dd><p>Indicates an unsupported configuration in MSR::QM_EVTSEL:*, and that <a class="reference internal" href="#msr-qm-ctr-rm-data"><span class="std std-ref">MSR::QM_CTR:RM_DATA</span></a> does not contain valid data. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-uncore-perf-status-freq"><span class="pre">MSR::UNCORE_PERF_STATUS:FREQ</span></code></dt><dd><p>The current uncore frequency.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: average</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pm-enable-hwp-enable"><span class="pre">MSR::PM_ENABLE:HWP_ENABLE</span></code></dt><dd><p>Indicates HWP enabled status.  Once enabled a system reset is required to disable. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-hwp-capabilities-highest-performance"><span class="pre">MSR::HWP_CAPABILITIES:HIGHEST_PERFORMANCE</span></code></dt><dd><p>Maximum non-guaranteed performance level when using HWP.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-hwp-capabilities-guaranteed-performance"><span class="pre">MSR::HWP_CAPABILITIES:GUARANTEED_PERFORMANCE</span></code></dt><dd><p>Current guaranteed performance level.  This may change dynamically based on various system constraints.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-hwp-capabilities-most-efficient-performance"><span class="pre">MSR::HWP_CAPABILITIES:MOST_EFFICIENT_PERFORMANCE</span></code></dt><dd><p>Current value of the most efficient performance level.  May change dynamically.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-hwp-capabilities-lowest-performance"><span class="pre">MSR::HWP_CAPABILITIES:LOWEST_PERFORMANCE</span></code></dt><dd><p>Minimum performance level when using HWP.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-hwp-request-desired-performance"><span class="pre">MSR::HWP_REQUEST:DESIRED_PERFORMANCE</span></code></dt><dd><p>An explicit performance request.  Setting to zero enables HWP Autonomous states.  Any other value effectively disables HWP Autonomous selection.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: average</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-hwp-request-activity-window"><span class="pre">MSR::HWP_REQUEST:ACTIVITY_WINDOW</span></code></dt><dd><p>A hint to HWP indicating the observation window for performance/frequency optimizations.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: average</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">MSR::CPU_SCALABILITY_RATIO</span></code></dt><dd><p>Measure of CPU Scalability as determined by the derivative
of PCNT divided by the derivative of ACNT over 8 samples.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: average</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: double</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
</dl>
</section>
</section>
<section id="controls">
<h2>Controls<a class="headerlink" href="#controls" title="Link to this heading"></a></h2>
<p>Some MSR controls are available on specific miroarchitectures.
<a class="reference internal" href="#architectural-controls"><span class="std std-ref">Architectural controls</span></a> are
available across Intel x86 microarchitectures.</p>
<nav class="contents local" id="categories-of-msr-controls">
<p class="topic-title">Categories of MSR controls:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#architectural-controls" id="id6">Architectural Controls</a></p></li>
<li><p><a class="reference internal" href="#knights-landing-knl-controls" id="id7">Knights Landing (KNL) Controls</a></p></li>
<li><p><a class="reference internal" href="#sandy-bridge-snb-controls" id="id8">Sandy Bridge (SNB) Controls</a></p></li>
<li><p><a class="reference internal" href="#haswell-hsx-controls" id="id9">Haswell (HSX) Controls</a></p></li>
<li><p><a class="reference internal" href="#skylake-skx-controls" id="id10">Skylake (SKX) Controls</a></p></li>
</ul>
</nav>
<section id="architectural-controls">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">Architectural Controls</a><a class="headerlink" href="#architectural-controls" title="Link to this heading"></a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate" id="msr-therm-status-thermal-status-log"><span class="pre">MSR::THERM_STATUS:THERMAL_STATUS_LOG</span></code></dt><dd><p>Indicates whether the core’s on-die sensor has read a high temperature (PROCHOT) since the last time a zero was written to this control. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-therm-status-prochot-log"><span class="pre">MSR::THERM_STATUS:PROCHOT_LOG</span></code></dt><dd><p>Indicates whether a high temperature (PROCHOT) or forced power reduction (FORCEPR) has been externally asserted since the last time a zero was written to this control. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-therm-status-critical-temp-log"><span class="pre">MSR::THERM_STATUS:CRITICAL_TEMP_LOG</span></code></dt><dd><p>Indicates whether the core’s on-die sensor has read a critical temperature since the last time a zero was written to this control. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-therm-status-thermal-thresh-1-log"><span class="pre">MSR::THERM_STATUS:THERMAL_THRESH_1_LOG</span></code></dt><dd><p>Indicates whether the core’s on-die sensor has read equal to or hotter than the threshold in <a class="reference internal" href="#msr-therm-interrupt-thresh-1"><span class="std std-ref">MSR::THERM_INTERRUPT:THRESH_1</span></a> since the last time a zero was written to this control. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-therm-status-thermal-thresh-2-log"><span class="pre">MSR::THERM_STATUS:THERMAL_THRESH_2_LOG</span></code></dt><dd><p>Indicates whether the core’s on-die sensor has read equal to or hotter than the threshold in <a class="reference internal" href="#msr-therm-interrupt-thresh-2"><span class="std std-ref">MSR::THERM_INTERRUPT:THRESH_2</span></a> since the last time a zero was written to this control. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-therm-status-power-notification-log"><span class="pre">MSR::THERM_STATUS:POWER_NOTIFICATION_LOG</span></code></dt><dd><p>Indicates whether requested P-States or requested clock duty cycles were not met at some point since the last time a zero was written to this control. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-misc-enable-fast-strings-enable"><span class="pre">MSR::MISC_ENABLE:FAST_STRINGS_ENABLE</span></code></dt><dd><p>Enable software control of the fast string feature for REP MOVS/STORS When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-misc-enable-enhanced-speedstep-tech-enable"><span class="pre">MSR::MISC_ENABLE:ENHANCED_SPEEDSTEP_TECH_ENABLE</span></code></dt><dd><p>Enable software control of P-States. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-misc-enable-turbo-mode-disable"><span class="pre">MSR::MISC_ENABLE:TURBO_MODE_DISABLE</span></code></dt><dd><p>Indicates whether opportunistic operating frequency above the processor’s base frequency is disabled. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-package-therm-status-thermal-status-log"><span class="pre">MSR::PACKAGE_THERM_STATUS:THERMAL_STATUS_LOG</span></code></dt><dd><p>Indicates whether the package’s on-die sensor has read a high temperature (PROCHOT) since the last time a zero was written to this control. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-package-therm-status-prochot-log"><span class="pre">MSR::PACKAGE_THERM_STATUS:PROCHOT_LOG</span></code></dt><dd><p>Indicates whether a package high temperature (PROCHOT) or forced power reduction (FORCEPR) has been externally asserted since the last time a zero was written to this control. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-package-therm-status-critical-temp-log"><span class="pre">MSR::PACKAGE_THERM_STATUS:CRITICAL_TEMP_LOG</span></code></dt><dd><p>Indicates whether the package’s on-die sensor has read a critical temperature since the last time a zero was written to this control. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-package-therm-status-thermal-thresh-1-log"><span class="pre">MSR::PACKAGE_THERM_STATUS:THERMAL_THRESH_1_LOG</span></code></dt><dd><p>Indicates whether the package’s on-die sensor has read equal to or hotter than the threshold in <a class="reference internal" href="#msr-package-therm-interrupt-thresh-1"><span class="std std-ref">MSR::PACKAGE_THERM_INTERRUPT:THRESH_1</span></a> since the last time a zero was written to this control. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-package-therm-status-thermal-thresh-2-log"><span class="pre">MSR::PACKAGE_THERM_STATUS:THERMAL_THRESH_2_LOG</span></code></dt><dd><p>Indicates whether the package’s on-die sensor has read equal to or hotter than the threshold in <a class="reference internal" href="#msr-package-therm-interrupt-thresh-2"><span class="std std-ref">MSR::PACKAGE_THERM_INTERRUPT:THRESH_2</span></a> since the last time a zero was written to this control. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-package-therm-status-power-notification-log"><span class="pre">MSR::PACKAGE_THERM_STATUS:POWER_NOTIFICATION_LOG</span></code></dt><dd><p>Indicates whether requested P-States or requested clock duty cycles were not met due to a package power limit at some point since the last time a zero was written to this control. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel0-event-select"><span class="pre">MSR::IA32_PERFEVTSEL0:EVENT_SELECT</span></code></dt><dd><p>Set an event code to select which event logic unit to monitor. This control combined with <a class="reference internal" href="#msr-ia32-perfevtsel0-umask"><span class="std std-ref">MSR::IA32_PERFEVTSEL0:UMASK</span></a> defines which event to count. See https://download.01.org/perfmon for possible input values. Event counts are accumulated in <a class="reference internal" href="#msr-ia32-pmc0-perfctr"><span class="std std-ref">MSR::IA32_PMC0:PERFCTR</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel0-umask"><span class="pre">MSR::IA32_PERFEVTSEL0:UMASK</span></code></dt><dd><p>Set a unit mask to select which event condition to monitor. This control combined with <a class="reference internal" href="#msr-ia32-perfevtsel0-event-select"><span class="std std-ref">MSR::IA32_PERFEVTSEL0:EVENT_SELECT</span></a> defines which event to count. See https://download.01.org/perfmon for possible input values. Event counts are accumulated in <a class="reference internal" href="#msr-ia32-pmc0-perfctr"><span class="std std-ref">MSR::IA32_PMC0:PERFCTR</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel0-usr"><span class="pre">MSR::IA32_PERFEVTSEL0:USR</span></code></dt><dd><p>Count events while in user mode. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel0-os"><span class="pre">MSR::IA32_PERFEVTSEL0:OS</span></code></dt><dd><p>Count events while in kernel mode. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel0-edge"><span class="pre">MSR::IA32_PERFEVTSEL0:EDGE</span></code></dt><dd><p>When set, count rising edges of the event signal instead of counting all instances where the event is observed. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel0-pc"><span class="pre">MSR::IA32_PERFEVTSEL0:PC</span></code></dt><dd><p>Only applicable prior to the Sandy Bridge microarchitecture. When set, the processor’s PMi pins are toggled (on then off in back-to-back clock cycles) when an event is counted. When cleared, only event counter overflows toggle the PMi pins. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel0-int"><span class="pre">MSR::IA32_PERFEVTSEL0:INT</span></code></dt><dd><p>If set, generate an interrupt when the counter overflows. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel0-anythread"><span class="pre">MSR::IA32_PERFEVTSEL0:ANYTHREAD</span></code></dt><dd><p>If set, increment event counts when the event occurs on any hardware thread from the configured thread’s core. Otherwise, only increment event counts when the configured thread triggers the event. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel0-en"><span class="pre">MSR::IA32_PERFEVTSEL0:EN</span></code></dt><dd><p>Enable the counters selected in MSR::IA32_PERFEVTSEL0 if both this and <a class="reference internal" href="#msr-perf-global-ctrl-en-pmc0"><span class="std std-ref">MSR::PERF_GLOBAL_CTRL:EN_PMC0</span></a> are set. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel0-inv"><span class="pre">MSR::IA32_PERFEVTSEL0:INV</span></code></dt><dd><p>Indicates whether non-zero <a class="reference internal" href="#msr-ia32-perfevtsel0-cmask"><span class="std std-ref">MSR::IA32_PERFEVTSEL0:CMASK</span></a> events should be inverted. When the CMASK is inverted, increment the event count when the number of occurrences is less than the configured cutoff, instead of the default behavior of counting when the number of occurrences is greater than or equal to the cutoff. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel0-cmask"><span class="pre">MSR::IA32_PERFEVTSEL0:CMASK</span></code></dt><dd><p>Set a mask for instances where multiple events are counted in a single clock cycle. When zero, all events are counted. When non-zero, a single event is counted when the number of event occurrences is greater or equal to the set CMASK value.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel1-event-select"><span class="pre">MSR::IA32_PERFEVTSEL1:EVENT_SELECT</span></code></dt><dd><p>Set an event code to select which event logic unit to monitor. This control combined with <a class="reference internal" href="#msr-ia32-perfevtsel1-umask"><span class="std std-ref">MSR::IA32_PERFEVTSEL1:UMASK</span></a> defines which event to count. See https://download.01.org/perfmon for possible input values. Event counts are accumulated in <a class="reference internal" href="#msr-ia32-pmc1-perfctr"><span class="std std-ref">MSR::IA32_PMC1:PERFCTR</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel1-umask"><span class="pre">MSR::IA32_PERFEVTSEL1:UMASK</span></code></dt><dd><p>Set a unit mask to select which event condition to monitor. This control combined with <a class="reference internal" href="#msr-ia32-perfevtsel1-event-select"><span class="std std-ref">MSR::IA32_PERFEVTSEL1:EVENT_SELECT</span></a> defines which event to count. See https://download.01.org/perfmon for possible input values. Event counts are accumulated in <a class="reference internal" href="#msr-ia32-pmc1-perfctr"><span class="std std-ref">MSR::IA32_PMC1:PERFCTR</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel1-usr"><span class="pre">MSR::IA32_PERFEVTSEL1:USR</span></code></dt><dd><p>Count events while in user mode. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel1-os"><span class="pre">MSR::IA32_PERFEVTSEL1:OS</span></code></dt><dd><p>Count events while in kernel mode. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel1-edge"><span class="pre">MSR::IA32_PERFEVTSEL1:EDGE</span></code></dt><dd><p>When set, count rising edges of the event signal instead of counting all instances where the event is observed. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel1-pc"><span class="pre">MSR::IA32_PERFEVTSEL1:PC</span></code></dt><dd><p>Only applicable prior to the Sandy Bridge microarchitecture. When set, the processor’s PMi pins are toggled (on then off in back-to-back clock cycles) when an event is counted. When cleared, only event counter overflows toggle the PMi pins. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel1-int"><span class="pre">MSR::IA32_PERFEVTSEL1:INT</span></code></dt><dd><p>If set, generate an interrupt when the counter overflows. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel1-anythread"><span class="pre">MSR::IA32_PERFEVTSEL1:ANYTHREAD</span></code></dt><dd><p>If set, increment event counts when the event occurs on any hardware thread from the configured thread’s core. Otherwise, only increment event counts when the configured thread triggers the event. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel1-en"><span class="pre">MSR::IA32_PERFEVTSEL1:EN</span></code></dt><dd><p>Enable the counters selected in MSR::IA32_PERFEVTSEL1 if both this and <a class="reference internal" href="#msr-perf-global-ctrl-en-pmc1"><span class="std std-ref">MSR::PERF_GLOBAL_CTRL:EN_PMC1</span></a> are set. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel1-inv"><span class="pre">MSR::IA32_PERFEVTSEL1:INV</span></code></dt><dd><p>Indicates whether non-zero <a class="reference internal" href="#msr-ia32-perfevtsel1-cmask"><span class="std std-ref">MSR::IA32_PERFEVTSEL1:CMASK</span></a> events should be inverted. When the CMASK is inverted, increment the event count when the number of occurrences is less than the configured cutoff, instead of the default behavior of counting when the number of occurrences is greater than or equal to the cutoff. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel1-cmask"><span class="pre">MSR::IA32_PERFEVTSEL1:CMASK</span></code></dt><dd><p>Set a mask for instances where multiple events are counted in a single clock cycle. When zero, all events are counted. When non-zero, a single event is counted when the number of event occurrences is greater or equal to the set CMASK value.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel2-event-select"><span class="pre">MSR::IA32_PERFEVTSEL2:EVENT_SELECT</span></code></dt><dd><p>Set an event code to select which event logic unit to monitor. This control combined with <a class="reference internal" href="#msr-ia32-perfevtsel2-umask"><span class="std std-ref">MSR::IA32_PERFEVTSEL2:UMASK</span></a> defines which event to count. See https://download.01.org/perfmon for possible input values. Event counts are accumulated in <a class="reference internal" href="#msr-ia32-pmc2-perfctr"><span class="std std-ref">MSR::IA32_PMC2:PERFCTR</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel2-umask"><span class="pre">MSR::IA32_PERFEVTSEL2:UMASK</span></code></dt><dd><p>Set a unit mask to select which event condition to monitor. This control combined with <a class="reference internal" href="#msr-ia32-perfevtsel2-event-select"><span class="std std-ref">MSR::IA32_PERFEVTSEL2:EVENT_SELECT</span></a> defines which event to count. See https://download.01.org/perfmon for possible input values. Event counts are accumulated in <a class="reference internal" href="#msr-ia32-pmc2-perfctr"><span class="std std-ref">MSR::IA32_PMC2:PERFCTR</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel2-usr"><span class="pre">MSR::IA32_PERFEVTSEL2:USR</span></code></dt><dd><p>Count events while in user mode. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel2-os"><span class="pre">MSR::IA32_PERFEVTSEL2:OS</span></code></dt><dd><p>Count events while in kernel mode. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel2-edge"><span class="pre">MSR::IA32_PERFEVTSEL2:EDGE</span></code></dt><dd><p>When set, count rising edges of the event signal instead of counting all instances where the event is observed. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel2-pc"><span class="pre">MSR::IA32_PERFEVTSEL2:PC</span></code></dt><dd><p>Only applicable prior to the Sandy Bridge microarchitecture. When set, the processor’s PMi pins are toggled (on then off in back-to-back clock cycles) when an event is counted. When cleared, only event counter overflows toggle the PMi pins. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel2-int"><span class="pre">MSR::IA32_PERFEVTSEL2:INT</span></code></dt><dd><p>If set, generate an interrupt when the counter overflows. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel2-anythread"><span class="pre">MSR::IA32_PERFEVTSEL2:ANYTHREAD</span></code></dt><dd><p>If set, increment event counts when the event occurs on any hardware thread from the configured thread’s core. Otherwise, only increment event counts when the configured thread triggers the event. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel2-en"><span class="pre">MSR::IA32_PERFEVTSEL2:EN</span></code></dt><dd><p>Enable the counters selected in MSR::IA32_PERFEVTSEL2 if both this and <a class="reference internal" href="#msr-perf-global-ctrl-en-pmc2"><span class="std std-ref">MSR::PERF_GLOBAL_CTRL:EN_PMC2</span></a> are set. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel2-inv"><span class="pre">MSR::IA32_PERFEVTSEL2:INV</span></code></dt><dd><p>Indicates whether non-zero <a class="reference internal" href="#msr-ia32-perfevtsel2-cmask"><span class="std std-ref">MSR::IA32_PERFEVTSEL2:CMASK</span></a> events should be inverted. When the CMASK is inverted, increment the event count when the number of occurrences is less than the configured cutoff, instead of the default behavior of counting when the number of occurrences is greater than or equal to the cutoff. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel2-cmask"><span class="pre">MSR::IA32_PERFEVTSEL2:CMASK</span></code></dt><dd><p>Set a mask for instances where multiple events are counted in a single clock cycle. When zero, all events are counted. When non-zero, a single event is counted when the number of event occurrences is greater or equal to the set CMASK value.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel3-event-select"><span class="pre">MSR::IA32_PERFEVTSEL3:EVENT_SELECT</span></code></dt><dd><p>Set an event code to select which event logic unit to monitor. This control combined with <a class="reference internal" href="#msr-ia32-perfevtsel3-umask"><span class="std std-ref">MSR::IA32_PERFEVTSEL3:UMASK</span></a> defines which event to count. See https://download.01.org/perfmon for possible input values. Event counts are accumulated in <a class="reference internal" href="#msr-ia32-pmc3-perfctr"><span class="std std-ref">MSR::IA32_PMC3:PERFCTR</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel3-umask"><span class="pre">MSR::IA32_PERFEVTSEL3:UMASK</span></code></dt><dd><p>Set a unit mask to select which event condition to monitor. This control combined with <a class="reference internal" href="#msr-ia32-perfevtsel3-event-select"><span class="std std-ref">MSR::IA32_PERFEVTSEL3:EVENT_SELECT</span></a> defines which event to count. See https://download.01.org/perfmon for possible input values. Event counts are accumulated in <a class="reference internal" href="#msr-ia32-pmc3-perfctr"><span class="std std-ref">MSR::IA32_PMC3:PERFCTR</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel3-usr"><span class="pre">MSR::IA32_PERFEVTSEL3:USR</span></code></dt><dd><p>Count events while in user mode. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel3-os"><span class="pre">MSR::IA32_PERFEVTSEL3:OS</span></code></dt><dd><p>Count events while in kernel mode. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel3-edge"><span class="pre">MSR::IA32_PERFEVTSEL3:EDGE</span></code></dt><dd><p>When set, count rising edges of the event signal instead of counting all instances where the event is observed. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel3-pc"><span class="pre">MSR::IA32_PERFEVTSEL3:PC</span></code></dt><dd><p>Only applicable prior to the Sandy Bridge microarchitecture. When set, the processor’s PMi pins are toggled (on then off in back-to-back clock cycles) when an event is counted. When cleared, only event counter overflows toggle the PMi pins. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel3-int"><span class="pre">MSR::IA32_PERFEVTSEL3:INT</span></code></dt><dd><p>If set, generate an interrupt when the counter overflows. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel3-anythread"><span class="pre">MSR::IA32_PERFEVTSEL3:ANYTHREAD</span></code></dt><dd><p>If set, increment event counts when the event occurs on any hardware thread from the configured thread’s core. Otherwise, only increment event counts when the configured thread triggers the event. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel3-en"><span class="pre">MSR::IA32_PERFEVTSEL3:EN</span></code></dt><dd><p>Enable the counters selected in MSR::IA32_PERFEVTSEL3 if both this and <a class="reference internal" href="#msr-perf-global-ctrl-en-pmc3"><span class="std std-ref">MSR::PERF_GLOBAL_CTRL:EN_PMC3</span></a> are set. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel3-inv"><span class="pre">MSR::IA32_PERFEVTSEL3:INV</span></code></dt><dd><p>Indicates whether non-zero <a class="reference internal" href="#msr-ia32-perfevtsel3-cmask"><span class="std std-ref">MSR::IA32_PERFEVTSEL3:CMASK</span></a> events should be inverted. When the CMASK is inverted, increment the event count when the number of occurrences is less than the configured cutoff, instead of the default behavior of counting when the number of occurrences is greater than or equal to the cutoff. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-ia32-perfevtsel3-cmask"><span class="pre">MSR::IA32_PERFEVTSEL3:CMASK</span></code></dt><dd><p>Set a mask for instances where multiple events are counted in a single clock cycle. When zero, all events are counted. When non-zero, a single event is counted when the number of event occurrences is greater or equal to the set CMASK value.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-fixed-ctr-ctrl-en0-os"><span class="pre">MSR::FIXED_CTR_CTRL:EN0_OS</span></code></dt><dd><p>Count <a class="reference internal" href="#msr-fixed-ctr0-inst-retired-any"><span class="std std-ref">MSR::FIXED_CTR0:INST_RETIRED_ANY</span></a> events while in kernel mode. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.  Requires geopmwrite -e.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-fixed-ctr-ctrl-en0-usr"><span class="pre">MSR::FIXED_CTR_CTRL:EN0_USR</span></code></dt><dd><p>Count <a class="reference internal" href="#msr-fixed-ctr0-inst-retired-any"><span class="std std-ref">MSR::FIXED_CTR0:INST_RETIRED_ANY</span></a> events while in user mode. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-fixed-ctr-ctrl-en0-pmi"><span class="pre">MSR::FIXED_CTR_CTRL:EN0_PMI</span></code></dt><dd><p>If set, generate an interrupt when the <a class="reference internal" href="#msr-fixed-ctr0-inst-retired-any"><span class="std std-ref">MSR::FIXED_CTR0:INST_RETIRED_ANY</span></a> counter overflows. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-fixed-ctr-ctrl-en1-os"><span class="pre">MSR::FIXED_CTR_CTRL:EN1_OS</span></code></dt><dd><p>Count <a class="reference internal" href="#msr-fixed-ctr1-cpu-clk-unhalted-thread"><span class="std std-ref">MSR::FIXED_CTR1:CPU_CLK_UNHALTED_THREAD</span></a> events while in kernel mode. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-fixed-ctr-ctrl-en1-usr"><span class="pre">MSR::FIXED_CTR_CTRL:EN1_USR</span></code></dt><dd><p>Count <a class="reference internal" href="#msr-fixed-ctr1-cpu-clk-unhalted-thread"><span class="std std-ref">MSR::FIXED_CTR1:CPU_CLK_UNHALTED_THREAD</span></a> events while in user mode. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-fixed-ctr-ctrl-en1-pmi"><span class="pre">MSR::FIXED_CTR_CTRL:EN1_PMI</span></code></dt><dd><p>If set, generate an interrupt when the <a class="reference internal" href="#msr-fixed-ctr1-cpu-clk-unhalted-thread"><span class="std std-ref">MSR::FIXED_CTR1:CPU_CLK_UNHALTED_THREAD</span></a> counter overflows. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-fixed-ctr-ctrl-en2-os"><span class="pre">MSR::FIXED_CTR_CTRL:EN2_OS</span></code></dt><dd><p>Count <a class="reference internal" href="#msr-fixed-ctr2-cpu-clk-unhalted-ref-tsc"><span class="std std-ref">MSR::FIXED_CTR2:CPU_CLK_UNHALTED_REF_TSC</span></a> events while in kernel mode. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-fixed-ctr-ctrl-en2-usr"><span class="pre">MSR::FIXED_CTR_CTRL:EN2_USR</span></code></dt><dd><p>Count <a class="reference internal" href="#msr-fixed-ctr2-cpu-clk-unhalted-ref-tsc"><span class="std std-ref">MSR::FIXED_CTR2:CPU_CLK_UNHALTED_REF_TSC</span></a> events while in user mode. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-fixed-ctr-ctrl-en2-pmi"><span class="pre">MSR::FIXED_CTR_CTRL:EN2_PMI</span></code></dt><dd><p>If set, generate an interrupt when the <a class="reference internal" href="#msr-fixed-ctr2-cpu-clk-unhalted-ref-tsc"><span class="std std-ref">MSR::FIXED_CTR2:CPU_CLK_UNHALTED_REF_TSC</span></a> counter overflows. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-perf-global-ctrl-en-pmc0"><span class="pre">MSR::PERF_GLOBAL_CTRL:EN_PMC0</span></code></dt><dd><p>Enable programmable counter 0 if both this and <a class="reference internal" href="#msr-ia32-perfevtsel0-en"><span class="std std-ref">MSR::IA32_PERFEVTSEL0:EN</span></a> are set. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-perf-global-ctrl-en-pmc1"><span class="pre">MSR::PERF_GLOBAL_CTRL:EN_PMC1</span></code></dt><dd><p>Enable programmable counter 1 if both this and <a class="reference internal" href="#msr-ia32-perfevtsel1-en"><span class="std std-ref">MSR::IA32_PERFEVTSEL1:EN</span></a> are set. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-perf-global-ctrl-en-pmc2"><span class="pre">MSR::PERF_GLOBAL_CTRL:EN_PMC2</span></code></dt><dd><p>Enable programmable counter 2 if both this and <a class="reference internal" href="#msr-ia32-perfevtsel2-en"><span class="std std-ref">MSR::IA32_PERFEVTSEL2:EN</span></a> are set. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-perf-global-ctrl-en-pmc3"><span class="pre">MSR::PERF_GLOBAL_CTRL:EN_PMC3</span></code></dt><dd><p>Enable programmable counter 3 if both this and <a class="reference internal" href="#msr-ia32-perfevtsel3-en"><span class="std std-ref">MSR::IA32_PERFEVTSEL3:EN</span></a> are set. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-perf-global-ctrl-en-fixed-ctr0"><span class="pre">MSR::PERF_GLOBAL_CTRL:EN_FIXED_CTR0</span></code></dt><dd><p>Enable the <a class="reference internal" href="#msr-fixed-ctr0-inst-retired-any"><span class="std std-ref">MSR::FIXED_CTR0:INST_RETIRED_ANY</span></a> counter. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-perf-global-ctrl-en-fixed-ctr1"><span class="pre">MSR::PERF_GLOBAL_CTRL:EN_FIXED_CTR1</span></code></dt><dd><p>Enable the <a class="reference internal" href="#msr-fixed-ctr1-cpu-clk-unhalted-thread"><span class="std std-ref">MSR::FIXED_CTR1:CPU_CLK_UNHALTED_THREAD</span></a> counter. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-perf-global-ctrl-en-fixed-ctr2"><span class="pre">MSR::PERF_GLOBAL_CTRL:EN_FIXED_CTR2</span></code></dt><dd><p>Enable the <a class="reference internal" href="#msr-fixed-ctr2-cpu-clk-unhalted-ref-tsc"><span class="std std-ref">MSR::FIXED_CTR2:CPU_CLK_UNHALTED_REF_TSC</span></a> counter. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-perf-global-ovf-ctrl-clear-ovf-pmc0"><span class="pre">MSR::PERF_GLOBAL_OVF_CTRL:CLEAR_OVF_PMC0</span></code></dt><dd><p>Write 1 to clear the global status bit for PMC0 overflow.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-perf-global-ovf-ctrl-clear-ovf-pmc1"><span class="pre">MSR::PERF_GLOBAL_OVF_CTRL:CLEAR_OVF_PMC1</span></code></dt><dd><p>Write 1 to clear the global status bit for PMC1 overflow.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-perf-global-ovf-ctrl-clear-ovf-pmc2"><span class="pre">MSR::PERF_GLOBAL_OVF_CTRL:CLEAR_OVF_PMC2</span></code></dt><dd><p>Write 1 to clear the global status bit for PMC2 overflow.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-perf-global-ovf-ctrl-clear-ovf-pmc3"><span class="pre">MSR::PERF_GLOBAL_OVF_CTRL:CLEAR_OVF_PMC3</span></code></dt><dd><p>Write 1 to clear the global status bit for PMC3 overflow.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-perf-global-ovf-ctrl-clear-ovf-fixed-ctr0"><span class="pre">MSR::PERF_GLOBAL_OVF_CTRL:CLEAR_OVF_FIXED_CTR0</span></code></dt><dd><p>Write 1 to clear the global status bit for <a class="reference internal" href="#msr-fixed-ctr0-inst-retired-any"><span class="std std-ref">MSR::FIXED_CTR0:INST_RETIRED_ANY</span></a> overflow.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-perf-global-ovf-ctrl-clear-ovf-fixed-ctr1"><span class="pre">MSR::PERF_GLOBAL_OVF_CTRL:CLEAR_OVF_FIXED_CTR1</span></code></dt><dd><p>Write 1 to clear the global status bit for <a class="reference internal" href="#msr-fixed-ctr1-cpu-clk-unhalted-thread"><span class="std std-ref">MSR::FIXED_CTR1:CPU_CLK_UNHALTED_THREAD</span></a> overflow.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-perf-global-ovf-ctrl-clear-ovf-fixed-ctr2"><span class="pre">MSR::PERF_GLOBAL_OVF_CTRL:CLEAR_OVF_FIXED_CTR2</span></code></dt><dd><p>Write 1 to clear the global status bit for <a class="reference internal" href="#msr-fixed-ctr2-cpu-clk-unhalted-ref-tsc"><span class="std std-ref">MSR::FIXED_CTR2:CPU_CLK_UNHALTED_REF_TSC</span></a> overflow.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
</dl>
</section>
<section id="knights-landing-knl-controls">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Knights Landing (KNL) Controls</a><a class="headerlink" href="#knights-landing-knl-controls" title="Link to this heading"></a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate" id="msr-perf-ctl-freq"><span class="pre">MSR::PERF_CTL:FREQ</span></code></dt><dd><p>Target operating frequency of the CPU based on the control register. When querying at a higher domain, if NaN is returned, query at its native domain.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: average</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl1-power-limit"><span class="pre">MSR::PKG_POWER_LIMIT:PL1_POWER_LIMIT</span></code></dt><dd><p>The average power usage limit over the time window specified in PL1_TIME_WINDOW.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl1-limit-enable"><span class="pre">MSR::PKG_POWER_LIMIT:PL1_LIMIT_ENABLE</span></code></dt><dd><p>Enable the limit specified in PL1_POWER_LIMIT. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl1-clamp-enable"><span class="pre">MSR::PKG_POWER_LIMIT:PL1_CLAMP_ENABLE</span></code></dt><dd><p>Allow processor cores to go below the requested P-State or T-State to achieve the requested PL1_POWER_LIMIT. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl1-time-window"><span class="pre">MSR::PKG_POWER_LIMIT:PL1_TIME_WINDOW</span></code></dt><dd><p>The time window associated with power limit 1.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl2-power-limit"><span class="pre">MSR::PKG_POWER_LIMIT:PL2_POWER_LIMIT</span></code></dt><dd><p>The average power usage limit over the time window specified in PL2_TIME_WINDOW.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl2-limit-enable"><span class="pre">MSR::PKG_POWER_LIMIT:PL2_LIMIT_ENABLE</span></code></dt><dd><p>Enable the limit specified in PL2_POWER_LIMIT. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl2-clamp-enable"><span class="pre">MSR::PKG_POWER_LIMIT:PL2_CLAMP_ENABLE</span></code></dt><dd><p>Allow processor cores to go below the requested P-State or T-State to achieve the requested PL2_POWER_LIMIT. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl2-time-window"><span class="pre">MSR::PKG_POWER_LIMIT:PL2_TIME_WINDOW</span></code></dt><dd><p>The time window associated with power limit 2.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-limit-power-limit"><span class="pre">MSR::DRAM_POWER_LIMIT:POWER_LIMIT</span></code></dt><dd><p>The average DRAM power usage limit over the time window specified in TIME_WINDOW.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-limit-enable"><span class="pre">MSR::DRAM_POWER_LIMIT:ENABLE</span></code></dt><dd><p>Enable the limit specified in POWER_LIMIT. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-limit-time-window"><span class="pre">MSR::DRAM_POWER_LIMIT:TIME_WINDOW</span></code></dt><dd><p>The time window associated with the DRAM power limit.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-uncore-ratio-limit-min-ratio"><span class="pre">MSR::UNCORE_RATIO_LIMIT:MIN_RATIO</span></code></dt><dd><p>A lower limit for uncore frequency control. When querying at a higher domain, if NaN is returned, query at its native domain.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-uncore-ratio-limit-max-ratio"><span class="pre">MSR::UNCORE_RATIO_LIMIT:MAX_RATIO</span></code></dt><dd><p>An upper limit for uncore frequency control. When querying at a higher domain, if NaN is returned, query at its native domain.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
</dl>
</section>
<section id="sandy-bridge-snb-controls">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Sandy Bridge (SNB) Controls</a><a class="headerlink" href="#sandy-bridge-snb-controls" title="Link to this heading"></a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate" id="msr-perf-ctl-freq"><span class="pre">MSR::PERF_CTL:FREQ</span></code></dt><dd><p>Target operating frequency of the CPU based on the control register. When querying at a higher domain, if NaN is returned, query at its native domain.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: average</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl1-power-limit"><span class="pre">MSR::PKG_POWER_LIMIT:PL1_POWER_LIMIT</span></code></dt><dd><p>The average power usage limit over the time window specified in PL1_TIME_WINDOW.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl1-limit-enable"><span class="pre">MSR::PKG_POWER_LIMIT:PL1_LIMIT_ENABLE</span></code></dt><dd><p>Enable the limit specified in PL1_POWER_LIMIT. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl1-clamp-enable"><span class="pre">MSR::PKG_POWER_LIMIT:PL1_CLAMP_ENABLE</span></code></dt><dd><p>Allow processor cores to go below the requested P-State or T-State to achieve the requested PL1_POWER_LIMIT. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl1-time-window"><span class="pre">MSR::PKG_POWER_LIMIT:PL1_TIME_WINDOW</span></code></dt><dd><p>The time window associated with power limit 1.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl2-power-limit"><span class="pre">MSR::PKG_POWER_LIMIT:PL2_POWER_LIMIT</span></code></dt><dd><p>The average power usage limit over the time window specified in PL2_TIME_WINDOW.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl2-limit-enable"><span class="pre">MSR::PKG_POWER_LIMIT:PL2_LIMIT_ENABLE</span></code></dt><dd><p>Enable the limit specified in PL2_POWER_LIMIT. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl2-clamp-enable"><span class="pre">MSR::PKG_POWER_LIMIT:PL2_CLAMP_ENABLE</span></code></dt><dd><p>Allow processor cores to go below the requested P-State or T-State to achieve the requested PL2_POWER_LIMIT. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl2-time-window"><span class="pre">MSR::PKG_POWER_LIMIT:PL2_TIME_WINDOW</span></code></dt><dd><p>The time window associated with power limit 2.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-limit-power-limit"><span class="pre">MSR::DRAM_POWER_LIMIT:POWER_LIMIT</span></code></dt><dd><p>The average DRAM power usage limit over the time window specified in TIME_WINDOW.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-limit-enable"><span class="pre">MSR::DRAM_POWER_LIMIT:ENABLE</span></code></dt><dd><p>Enable the limit specified in POWER_LIMIT. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-limit-time-window"><span class="pre">MSR::DRAM_POWER_LIMIT:TIME_WINDOW</span></code></dt><dd><p>The time window associated with the DRAM power limit.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
</dl>
</section>
<section id="haswell-hsx-controls">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">Haswell (HSX) Controls</a><a class="headerlink" href="#haswell-hsx-controls" title="Link to this heading"></a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate" id="msr-perf-ctl-freq"><span class="pre">MSR::PERF_CTL:FREQ</span></code></dt><dd><p>Target operating frequency of the CPU based on the control register. When querying at a higher domain, if NaN is returned, query at its native domain.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: average</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-turbo-ratio-limit2-pcu-semaphore"><span class="pre">MSR::TURBO_RATIO_LIMIT2:PCU_SEMAPHORE</span></code></dt><dd><p>Indicates whether MSR::TURBO_RATIO_LIMIT* settings are used instead of the the factory-set limits. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl1-power-limit"><span class="pre">MSR::PKG_POWER_LIMIT:PL1_POWER_LIMIT</span></code></dt><dd><p>The average power usage limit over the time window specified in PL1_TIME_WINDOW.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl1-limit-enable"><span class="pre">MSR::PKG_POWER_LIMIT:PL1_LIMIT_ENABLE</span></code></dt><dd><p>Enable the limit specified in PL1_POWER_LIMIT. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl1-clamp-enable"><span class="pre">MSR::PKG_POWER_LIMIT:PL1_CLAMP_ENABLE</span></code></dt><dd><p>Allow processor cores to go below the requested P-State or T-State to achieve the requested PL1_POWER_LIMIT. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl1-time-window"><span class="pre">MSR::PKG_POWER_LIMIT:PL1_TIME_WINDOW</span></code></dt><dd><p>The time window associated with power limit 1.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl2-power-limit"><span class="pre">MSR::PKG_POWER_LIMIT:PL2_POWER_LIMIT</span></code></dt><dd><p>The average power usage limit over the time window specified in PL2_TIME_WINDOW.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl2-limit-enable"><span class="pre">MSR::PKG_POWER_LIMIT:PL2_LIMIT_ENABLE</span></code></dt><dd><p>Enable the limit specified in PL2_POWER_LIMIT. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl2-clamp-enable"><span class="pre">MSR::PKG_POWER_LIMIT:PL2_CLAMP_ENABLE</span></code></dt><dd><p>Allow processor cores to go below the requested P-State or T-State to achieve the requested PL2_POWER_LIMIT. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl2-time-window"><span class="pre">MSR::PKG_POWER_LIMIT:PL2_TIME_WINDOW</span></code></dt><dd><p>The time window associated with power limit 2.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-limit-power-limit"><span class="pre">MSR::DRAM_POWER_LIMIT:POWER_LIMIT</span></code></dt><dd><p>The average DRAM power usage limit over the time window specified in TIME_WINDOW.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-limit-enable"><span class="pre">MSR::DRAM_POWER_LIMIT:ENABLE</span></code></dt><dd><p>Enable the limit specified in POWER_LIMIT. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-limit-time-window"><span class="pre">MSR::DRAM_POWER_LIMIT:TIME_WINDOW</span></code></dt><dd><p>The time window associated with the DRAM power limit.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-uncore-ratio-limit-min-ratio"><span class="pre">MSR::UNCORE_RATIO_LIMIT:MIN_RATIO</span></code></dt><dd><p>A lower limit for uncore frequency control. When querying at a higher domain, if NaN is returned, query at its native domain.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-uncore-ratio-limit-max-ratio"><span class="pre">MSR::UNCORE_RATIO_LIMIT:MAX_RATIO</span></code></dt><dd><p>An upper limit for uncore frequency control. When querying at a higher domain, if NaN is returned, query at its native domain.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
</dl>
</section>
<section id="skylake-skx-controls">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Skylake (SKX) Controls</a><a class="headerlink" href="#skylake-skx-controls" title="Link to this heading"></a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate" id="msr-perf-ctl-freq"><span class="pre">MSR::PERF_CTL:FREQ</span></code></dt><dd><p>Target operating frequency of the CPU based on the control register. When querying at a higher domain, if NaN is returned, query at its native domain.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: average</p></li>
<li><p><strong>Domain</strong>: core</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl1-power-limit"><span class="pre">MSR::PKG_POWER_LIMIT:PL1_POWER_LIMIT</span></code></dt><dd><p>The average power usage limit over the time window specified in PL1_TIME_WINDOW.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl1-limit-enable"><span class="pre">MSR::PKG_POWER_LIMIT:PL1_LIMIT_ENABLE</span></code></dt><dd><p>Enable the limit specified in PL1_POWER_LIMIT. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl1-clamp-enable"><span class="pre">MSR::PKG_POWER_LIMIT:PL1_CLAMP_ENABLE</span></code></dt><dd><p>Allow processor cores to go below the requested P-State or T-State to achieve the requested PL1_POWER_LIMIT. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl1-time-window"><span class="pre">MSR::PKG_POWER_LIMIT:PL1_TIME_WINDOW</span></code></dt><dd><p>The time window associated with power limit 1.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl2-power-limit"><span class="pre">MSR::PKG_POWER_LIMIT:PL2_POWER_LIMIT</span></code></dt><dd><p>The average power usage limit over the time window specified in PL2_TIME_WINDOW.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl2-limit-enable"><span class="pre">MSR::PKG_POWER_LIMIT:PL2_LIMIT_ENABLE</span></code></dt><dd><p>Enable the limit specified in PL2_POWER_LIMIT. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl2-clamp-enable"><span class="pre">MSR::PKG_POWER_LIMIT:PL2_CLAMP_ENABLE</span></code></dt><dd><p>Allow processor cores to go below the requested P-State or T-State to achieve the requested PL2_POWER_LIMIT. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pkg-power-limit-pl2-time-window"><span class="pre">MSR::PKG_POWER_LIMIT:PL2_TIME_WINDOW</span></code></dt><dd><p>The time window associated with power limit 2.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-limit-power-limit"><span class="pre">MSR::DRAM_POWER_LIMIT:POWER_LIMIT</span></code></dt><dd><p>The average DRAM power usage limit over the time window specified in TIME_WINDOW.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: watts</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-limit-enable"><span class="pre">MSR::DRAM_POWER_LIMIT:ENABLE</span></code></dt><dd><p>Enable the limit specified in POWER_LIMIT. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-dram-power-limit-time-window"><span class="pre">MSR::DRAM_POWER_LIMIT:TIME_WINDOW</span></code></dt><dd><p>The time window associated with the DRAM power limit.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: memory</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: seconds</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-uncore-ratio-limit-min-ratio"><span class="pre">MSR::UNCORE_RATIO_LIMIT:MIN_RATIO</span></code></dt><dd><p>A lower limit for uncore frequency control. When querying at a higher domain, if NaN is returned, query at its native domain.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-uncore-ratio-limit-max-ratio"><span class="pre">MSR::UNCORE_RATIO_LIMIT:MAX_RATIO</span></code></dt><dd><p>An upper limit for uncore frequency control. When querying at a higher domain, if NaN is returned, query at its native domain.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-qm-evtsel-event-id"><span class="pre">MSR::QM_EVTSEL:EVENT_ID</span></code></dt><dd><p>Set an event code to choose which resource is monitored in <a class="reference internal" href="#msr-qm-ctr-rm-data"><span class="std std-ref">MSR::QM_CTR:RM_DATA</span></a>. Refer to the Intel(R) 64 and IA-32 Architectures Software Developer’s Manual for more information about how to use this MSR with Cache Monitoring Technology and Memory Bandwidth Monitoring. Event counts are accumulated in MSR::QM_CTR::RM_DATA.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-qm-evtsel-rmid"><span class="pre">MSR::QM_EVTSEL:RMID</span></code></dt><dd><p>Specify which resource monitoring identifier (RMID) must be active to update <a class="reference internal" href="#msr-qm-ctr-rm-data"><span class="std std-ref">MSR::QM_CTR:RM_DATA</span></a>. Associate RMIDs with CPUs by writing to <a class="reference internal" href="#msr-pqr-assoc-rmid"><span class="std std-ref">MSR::PQR_ASSOC:RMID</span></a>.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: package</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-pqr-assoc-rmid"><span class="pre">MSR::PQR_ASSOC:RMID</span></code></dt><dd><p>The resource monitoring identifier (RMID) currently associated with this CPU. Multiple CPUs are permitted to map to the same RMID. RMID-based resource monitoring interfaces track each monitored resource by a CPU package, RMID pair.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: expect_same</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-misc-feature-control-l2-hw-prefetcher-disable"><span class="pre">MSR::MISC_FEATURE_CONTROL:L2_HW_PREFETCHER_DISABLE</span></code></dt><dd><p>Disable for the L2 hardware prefetcher. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-misc-feature-control-l2-adjacent-prefetcher-disable"><span class="pre">MSR::MISC_FEATURE_CONTROL:L2_ADJACENT_PREFETCHER_DISABLE</span></code></dt><dd><p>Disable for the L2 adjacent cache line prefetcher When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-misc-feature-control-dcu-hw-prefetcher-disable"><span class="pre">MSR::MISC_FEATURE_CONTROL:DCU_HW_PREFETCHER_DISABLE</span></code></dt><dd><p>Disable for the L1 data cache prefetcher When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-misc-feature-control-dcu-ip-prefetcher-disable"><span class="pre">MSR::MISC_FEATURE_CONTROL:DCU_IP_PREFETCHER_DISABLE</span></code></dt><dd><p>Disable for the L1 data cache instruction pointer prefetcher When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-hwp-request-minimum-performance"><span class="pre">MSR::HWP_REQUEST:MINIMUM_PERFORMANCE</span></code></dt><dd><p>A hint to HWP on the minimum performance level required.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: average</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-hwp-request-maximum-performance"><span class="pre">MSR::HWP_REQUEST:MAXIMUM_PERFORMANCE</span></code></dt><dd><p>A hint to HWP on the maximum performance level required.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: average</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: hertz</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-hwp-request-energy-performance-preference"><span class="pre">MSR::HWP_REQUEST:ENERGY_PERFORMANCE_PREFERENCE</span></code></dt><dd><p>Influences rate of performance increase/decrease.  0x00 = performance, 0xFF = energy efficiency.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: average</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-hwp-request-package-control"><span class="pre">MSR::HWP_REQUEST:PACKAGE_CONTROL</span></code></dt><dd><p>If set overrides requests with the package level request. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-hwp-request-epp-valid"><span class="pre">MSR::HWP_REQUEST:EPP_VALID</span></code></dt><dd><p>If set indicates HWP should use the related cpu MSR field value regardless of the PACKAGE_CONTROL bit setting. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-hwp-request-desired-valid"><span class="pre">MSR::HWP_REQUEST:DESIRED_VALID</span></code></dt><dd><p>If set indicates HWP should use the related cpu MSR field value regardless of the PACKAGE_CONTROL bit setting. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-hwp-request-maximum-valid"><span class="pre">MSR::HWP_REQUEST:MAXIMUM_VALID</span></code></dt><dd><p>If set indicates HWP should use the related cpu MSR field value regardless of the PACKAGE_CONTROL bit setting. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-hwp-request-minimum-valid"><span class="pre">MSR::HWP_REQUEST:MINIMUM_VALID</span></code></dt><dd><p>If set indicates HWP should use the related cpu MSR field value regardless of the PACKAGE_CONTROL bit setting. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-hwp-status-guaranteed-performance-change"><span class="pre">MSR::HWP_STATUS:GUARANTEED_PERFORMANCE_CHANGE</span></code></dt><dd><p>Log bit indicating if a GUARANTEED_PERFORMANCE change has occurred.  Software responsible to clear via write to 0. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-hwp-status-excursion-to-minimum"><span class="pre">MSR::HWP_STATUS:EXCURSION_TO_MINIMUM</span></code></dt><dd><p>Log bit indicating if an excursion below the minimum requested performance has occurred.  Software responsible to clear via write to 0. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-hwp-status-highest-change"><span class="pre">MSR::HWP_STATUS:HIGHEST_CHANGE</span></code></dt><dd><p>Log bit indicating if a HIGHEST_PEROFRMANCE change has occurred.  Software responsible to clear via write to 0. When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-hwp-status-peci-override-entry"><span class="pre">MSR::HWP_STATUS:PECI_OVERRIDE_ENTRY</span></code></dt><dd><p>Indicates a PECI override request that will override the HWP MSR values has started.  Software responsible to clear via write to 0 When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate" id="msr-hwp-status-peci-override-exit"><span class="pre">MSR::HWP_STATUS:PECI_OVERRIDE_EXIT</span></code></dt><dd><p>Indicates a PECI override request that will override the HWP MSR values has ended.  Software responsible to clear via write to 0 When reading at a higher level domain than its native domain, it aggregates as the count of all such bits that have been set.</p>
<ul class="simple">
<li><p><strong>Aggregation</strong>: sum</p></li>
<li><p><strong>Domain</strong>: cpu</p></li>
<li><p><strong>Format</strong>: integer</p></li>
<li><p><strong>Unit</strong>: none</p></li>
</ul>
</dd>
</dl>
</section>
</section>
<section id="aliases">
<h2>Aliases<a class="headerlink" href="#aliases" title="Link to this heading"></a></h2>
<p>This IOGroup provides the following high-level aliases:</p>
<section id="signal-aliases">
<h3>Signal Aliases<a class="headerlink" href="#signal-aliases" title="Link to this heading"></a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">BOARD_ENERGY</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::PLATFORM_ENERGY_STATUS:ENERGY</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BOARD_POWER</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::BOARD_POWER</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BOARD_POWER_LIMIT_CONTROL</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::PLATFORM_POWER_LIMIT:PL1_POWER_LIMIT</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">BOARD_POWER_TIME_WINDOW_CONTROL</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::PLATFORM_POWER_LIMIT:PL1_TIME_WINDOW</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_CORE_TEMPERATURE</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::THERM_STATUS:DIGITAL_READOUT</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_CYCLES_REFERENCE</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::MPERF:MCNT</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_CYCLES_THREAD</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::APERF:ACNT</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_ENERGY</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::PKG_ENERGY_STATUS:ENERGY</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_FREQUENCY_MAX_CONTROL</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::HWP_REQUEST:MAXIMUM_PERFORMANCE</span></code> or to <code class="docutils literal notranslate"><span class="pre">MSR::PERF_CTL:FREQ</span></code> if HWP is disabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_FREQUENCY_MAX_AVAIL</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::TURBO_RATIO_LIMIT:MAX_RATIO_LIMIT_0</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_FREQUENCY_MIN_CONTROL</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::HWP_REQUEST:MINIMUM_PERFORMANCE</span></code>.  Not exposed if HWP is disabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_FREQUENCY_STATUS</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::PERF_STATUS:FREQ</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_INSTRUCTIONS_RETIRED</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::FIXED_CTR0:INST_RETIRED_ANY</span></code>.  Requires the fixed counters to be enabled (<code class="docutils literal notranslate"><span class="pre">geopmwrite</span> <span class="pre">-e</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_PACKAGE_TEMPERATURE</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::PACKAGE_THERM_STATUS:DIGITAL_READOUT</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_POWER</span></code></dt><dd><p>Average package power over 40 ms or 8 control loop iterations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_POWER_LIMIT_CONTROL</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::PKG_POWER_LIMIT:PL1_POWER_LIMIT</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_POWER_MAX_AVAIL</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::PKG_POWER_INFO:MAX_POWER</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_POWER_MIN_AVAIL</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::PKG_POWER_INFO:MIN_POWER</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_POWER_LIMIT_DEFAULT</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::PKG_POWER_INFO:THERMAL_SPEC_POWER</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_POWER_TIME_WINDOW_CONTROL</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::PKG_POWER_LIMIT:PL1_TIME_WINDOW</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_TIMESTAMP_COUNTER</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::TIME_STAMP_COUNTER:TIMESTAMP_COUNT</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_UNCORE_FREQUENCY_MAX_CONTROL</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::UNCORE_RATIO_LIMIT:MAX_RATIO</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_UNCORE_FREQUENCY_MIN_CONTROL</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::UNCORE_RATIO_LIMIT:MIN_RATIO</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_UNCORE_FREQUENCY_STATUS</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::UNCORE_PERF_STATUS:FREQ</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRAM_ENERGY</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::DRAM_ENERGY_STATUS:ENERGY</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DRAM_POWER</span></code></dt><dd><p>Average DRAM power over 40 ms or 8 control loop iterations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MSR::BOARD_ENERGY</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::PLATFORM_ENERGY_STATUS:ENERGY</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MSR::BOARD_POWER</span></code></dt><dd><p>Average board power over 40 ms or 8 control loop iterations.  Derived from <code class="docutils literal notranslate"><span class="pre">MSR::BOARD_ENERGY</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MSR::QM_CTR_SCALED</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::QM_CTR:RM_DATA</span></code>, scaled by the processor’s counter resolution for bandwidth accounting in bytes.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MSR::QM_CTR_SCALED_RATE</span></code></dt><dd><p>Maps to the rate of change in <code class="docutils literal notranslate"><span class="pre">MSR::QM_CTR_SCALED</span></code>.</p>
</dd>
</dl>
</section>
<section id="control-aliases">
<h3>Control Aliases<a class="headerlink" href="#control-aliases" title="Link to this heading"></a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">CPU_FREQUENCY_DESIRED_CONTROL</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::HWP_REQUEST:DESIRED_PERFORMANCE</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_FREQUENCY_MAX_CONTROL</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::HWP_REQUEST:MAXIMUM_PERFORMANCE</span></code> or to <code class="docutils literal notranslate"><span class="pre">MSR::PERF_CTL:FREQ</span></code> if HWP is disabled</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_FREQUENCY_MIN_CONTROL</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::HWP_REQUEST:MINIMUM_PERFORMANCE</span></code>.  Not exposed if HWP is disabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_POWER_LIMIT_CONTROL</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::PKG_POWER_LIMIT:PL1_POWER_LIMIT</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_POWER_TIME_WINDOW_CONTROL</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::PKG_POWER_LIMIT:PL1_TIME_WINDOW</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_UNCORE_FREQUENCY_MAX_CONTROL</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::UNCORE_RATIO_LIMIT:MAX_RATIO</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CPU_UNCORE_FREQUENCY_MIN_CONTROL</span></code></dt><dd><p>Maps to <code class="docutils literal notranslate"><span class="pre">MSR::UNCORE_RATIO_LIMIT:MIN_RATIO</span></code></p>
</dd>
</dl>
</section>
</section>
<section id="example">
<h2>Example<a class="headerlink" href="#example" title="Link to this heading"></a></h2>
<p>The following example uses geopmread and geopmwrite command-line tools.
These steps can also be followed within an agent.</p>
<section id="setting-frequency">
<h3>Setting Frequency<a class="headerlink" href="#setting-frequency" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>Set target operating frequency:</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">geopmwrite</span> <span class="pre">CPU_FREQUENCY_MAX_CONTROL</span> <span class="pre">core</span> <span class="pre">0</span> <span class="pre">1700000000</span></code></p>
<ul class="simple">
<li><p>Read setting and current operating frequency:</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">geopmread</span> <span class="pre">CPU_FREQUENCY_MAX_CONTROL</span> <span class="pre">core</span> <span class="pre">0</span></code>
<code class="docutils literal notranslate"><span class="pre">geopmread</span> <span class="pre">CPU_FREQUENCY_STATUS</span> <span class="pre">core</span> <span class="pre">0</span></code></p>
</section>
<section id="setting-a-power-limit">
<h3>Setting A Power Limit<a class="headerlink" href="#setting-a-power-limit" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>Set power limit</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">geopmwrite</span> <span class="pre">CPU_POWER_LIMIT_CONTROL</span> <span class="pre">package</span> <span class="pre">0</span> <span class="pre">20</span></code></p>
<ul class="simple">
<li><p>Read setting and current power</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">geopmread</span> <span class="pre">CPU_POWER_LIMIT_CONTROL</span> <span class="pre">package</span> <span class="pre">0</span></code>
<code class="docutils literal notranslate"><span class="pre">geopmread</span> <span class="pre">CPU_POWER</span> <span class="pre">package</span> <span class="pre">0</span></code></p>
</section>
</section>
<section id="see-also">
<h2>See Also<a class="headerlink" href="#see-also" title="Link to this heading"></a></h2>
<p><a class="reference internal" href="geopm_pio.7.html"><span class="doc">geopm_pio(7)</span></a>,
<a class="reference internal" href="geopm.7.html"><span class="doc">geopm(7)</span></a>,
<a class="reference internal" href="geopm%3A%3AIOGroup.3.html"><span class="doc">geopm::IOGroup(3)</span></a>,
<a class="reference internal" href="geopmwrite.1.html"><span class="doc">geopmwrite(1)</span></a>,
<a class="reference internal" href="geopmread.1.html"><span class="doc">geopmread(1)</span></a></p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="geopm_pio_levelzero.7.html" class="btn btn-neutral float-left" title="geopm_pio_levelzero(7) – IOGroup providing signals and controls for Intel GPUs" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="geopm_pio_nvml.7.html" class="btn btn-neutral float-right" title="geopm_pio_nvml(7) – IOGroup providing signals and controls for NVIDIA GPUs" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015 - 2024 Intel Corporation. All rights reserved..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>