<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>geopm: geopm::Agent Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">geopm
   &#160;<span id="projectnumber">2.0.0+dev4gf50915a8</span>
   </div>
   <div id="projectbrief">GEOPM - Global Extensible Open Power Manager</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegeopm.html">geopm</a></li><li class="navelem"><a class="el" href="classgeopm_1_1_agent.html">Agent</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classgeopm_1_1_agent-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">geopm::Agent Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_agent_8hpp_source.html">Agent.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for geopm::Agent:</div>
<div class="dyncontent">
<div class="center"><img src="classgeopm_1_1_agent__inherit__graph.png" border="0" usemap="#geopm_1_1_agent_inherit__map" alt="Inheritance graph"/></div>
<map name="geopm_1_1_agent_inherit__map" id="geopm_1_1_agent_inherit__map">
<area shape="rect" id="node2" href="classgeopm_1_1_frequency_map_agent.html" title="geopm::FrequencyMapAgent" alt="" coords="157,5,346,32"/>
<area shape="rect" id="node3" href="classgeopm_1_1_monitor_agent.html" title="Agent used to do sampling only; no policy will be enforced. " alt="" coords="178,56,325,83"/>
<area shape="rect" id="node4" href="classgeopm_1_1_power_balancer_agent.html" title="geopm::PowerBalancerAgent" alt="" coords="156,107,347,133"/>
<area shape="rect" id="node5" href="classgeopm_1_1_power_governor_agent.html" title="geopm::PowerGovernorAgent" alt="" coords="156,157,347,184"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a63f44ae327dda74fa4b9642c580aece2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a63f44ae327dda74fa4b9642c580aece2">Agent</a> ()=default</td></tr>
<tr class="separator:a63f44ae327dda74fa4b9642c580aece2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25bcbffb10acf177ac9294f24a6e211"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#ae25bcbffb10acf177ac9294f24a6e211">~Agent</a> ()=default</td></tr>
<tr class="separator:ae25bcbffb10acf177ac9294f24a6e211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c94fff3ed8f580526e51aeb25cf4758"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a2c94fff3ed8f580526e51aeb25cf4758">init</a> (int level, const std::vector&lt; int &gt; &amp;fan_in, bool is_level_root)=0</td></tr>
<tr class="memdesc:a2c94fff3ed8f580526e51aeb25cf4758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the level where this <a class="el" href="classgeopm_1_1_agent.html">Agent</a> is active and push signals/controls for that level.  <a href="#a2c94fff3ed8f580526e51aeb25cf4758">More...</a><br /></td></tr>
<tr class="separator:a2c94fff3ed8f580526e51aeb25cf4758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f4eb74c2f1c50b9c85fc988de8c4c0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a76f4eb74c2f1c50b9c85fc988de8c4c0">validate_policy</a> (std::vector&lt; double &gt; &amp;policy) const =0</td></tr>
<tr class="memdesc:a76f4eb74c2f1c50b9c85fc988de8c4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="classgeopm_1_1_controller.html">Controller</a> to validate incoming policy values and configure defaults requested in incoming policy. Policy sender can request default value with 'NaN' at the desired offset in the policy vector. Returned policy should not contain 'NaN's and be consumeable by descend and adjust_platform.  <a href="#a76f4eb74c2f1c50b9c85fc988de8c4c0">More...</a><br /></td></tr>
<tr class="separator:a76f4eb74c2f1c50b9c85fc988de8c4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33501debc601b7a69bee243c9a3a2351"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a33501debc601b7a69bee243c9a3a2351">split_policy</a> (const std::vector&lt; double &gt; &amp;in_policy, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;out_policy)=0</td></tr>
<tr class="memdesc:a33501debc601b7a69bee243c9a3a2351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="classgeopm_1_1_controller.html">Controller</a> to split policy for children at next level down the tree.  <a href="#a33501debc601b7a69bee243c9a3a2351">More...</a><br /></td></tr>
<tr class="separator:a33501debc601b7a69bee243c9a3a2351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31a7c9beb554f2e992b8ba3f550edd0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#aa31a7c9beb554f2e992b8ba3f550edd0">do_send_policy</a> (void) const =0</td></tr>
<tr class="memdesc:aa31a7c9beb554f2e992b8ba3f550edd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="classgeopm_1_1_controller.html">Controller</a> to determine if new policy values should be sent down the tree to the <a class="el" href="classgeopm_1_1_agent.html">Agent</a>'s children.  <a href="#aa31a7c9beb554f2e992b8ba3f550edd0">More...</a><br /></td></tr>
<tr class="separator:aa31a7c9beb554f2e992b8ba3f550edd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466fec62dd739ac1202bee83bb48a84c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a466fec62dd739ac1202bee83bb48a84c">aggregate_sample</a> (const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;in_sample, std::vector&lt; double &gt; &amp;out_sample)=0</td></tr>
<tr class="memdesc:a466fec62dd739ac1202bee83bb48a84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregate samples from children for the next level up the tree.  <a href="#a466fec62dd739ac1202bee83bb48a84c">More...</a><br /></td></tr>
<tr class="separator:a466fec62dd739ac1202bee83bb48a84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba9bc5764872dd01f8b02759f7f2563"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a0ba9bc5764872dd01f8b02759f7f2563">do_send_sample</a> (void) const =0</td></tr>
<tr class="separator:a0ba9bc5764872dd01f8b02759f7f2563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4d973b78871fb7064aec3071958fdd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a4a4d973b78871fb7064aec3071958fdd">adjust_platform</a> (const std::vector&lt; double &gt; &amp;in_policy)=0</td></tr>
<tr class="memdesc:a4a4d973b78871fb7064aec3071958fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust the platform settings based the policy from above.  <a href="#a4a4d973b78871fb7064aec3071958fdd">More...</a><br /></td></tr>
<tr class="separator:a4a4d973b78871fb7064aec3071958fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb97f2b7119ab9b38af3ccc18f935324"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#afb97f2b7119ab9b38af3ccc18f935324">do_write_batch</a> (void) const =0</td></tr>
<tr class="memdesc:afb97f2b7119ab9b38af3ccc18f935324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the <a class="el" href="classgeopm_1_1_controller.html">Controller</a> to decide whether to call write_batch() to update platform controls.  <a href="#afb97f2b7119ab9b38af3ccc18f935324">More...</a><br /></td></tr>
<tr class="separator:afb97f2b7119ab9b38af3ccc18f935324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223cbd5f3cd63829387a0b9a67166b19"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a223cbd5f3cd63829387a0b9a67166b19">sample_platform</a> (std::vector&lt; double &gt; &amp;out_sample)=0</td></tr>
<tr class="memdesc:a223cbd5f3cd63829387a0b9a67166b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read signals from the platform and interpret/aggregate these signals to create a sample which can be sent up the tree.  <a href="#a223cbd5f3cd63829387a0b9a67166b19">More...</a><br /></td></tr>
<tr class="separator:a223cbd5f3cd63829387a0b9a67166b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2c88ac43e7ec80e92e541ddf093ecc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a0d2c88ac43e7ec80e92e541ddf093ecc">wait</a> (void)=0</td></tr>
<tr class="memdesc:a0d2c88ac43e7ec80e92e541ddf093ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="classgeopm_1_1_controller.html">Controller</a> to wait for sample period to elapse. This controls the cadence of the <a class="el" href="classgeopm_1_1_controller.html">Controller</a> main loop.  <a href="#a0d2c88ac43e7ec80e92e541ddf093ecc">More...</a><br /></td></tr>
<tr class="separator:a0d2c88ac43e7ec80e92e541ddf093ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a830e95ed99627519e4f800d4d45bc"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#ab1a830e95ed99627519e4f800d4d45bc">report_header</a> (void) const =0</td></tr>
<tr class="memdesc:ab1a830e95ed99627519e4f800d4d45bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom fields that will be added to the report header when this agent is used.  <a href="#ab1a830e95ed99627519e4f800d4d45bc">More...</a><br /></td></tr>
<tr class="separator:ab1a830e95ed99627519e4f800d4d45bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d89f3b7147ead870b3397ea9512a436"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a8d89f3b7147ead870b3397ea9512a436">report_host</a> (void) const =0</td></tr>
<tr class="memdesc:a8d89f3b7147ead870b3397ea9512a436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom fields for the host section of the report.  <a href="#a8d89f3b7147ead870b3397ea9512a436">More...</a><br /></td></tr>
<tr class="separator:a8d89f3b7147ead870b3397ea9512a436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cedd11bbf8fb256f25da5e83175d18"><td class="memItemLeft" align="right" valign="top">virtual std::map&lt; uint64_t, std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a80cedd11bbf8fb256f25da5e83175d18">report_region</a> (void) const =0</td></tr>
<tr class="memdesc:a80cedd11bbf8fb256f25da5e83175d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom fields for each region in the report.  <a href="#a80cedd11bbf8fb256f25da5e83175d18">More...</a><br /></td></tr>
<tr class="separator:a80cedd11bbf8fb256f25da5e83175d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854cbf10df12e4e53b98a658779d6d53"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a854cbf10df12e4e53b98a658779d6d53">trace_names</a> (void) const =0</td></tr>
<tr class="memdesc:a854cbf10df12e4e53b98a658779d6d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column headers to be added to the trace.  <a href="#a854cbf10df12e4e53b98a658779d6d53">More...</a><br /></td></tr>
<tr class="separator:a854cbf10df12e4e53b98a658779d6d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e87cbbea1c0ca534f6a16f6fedc492"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::function&lt; std::string(double)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a89e87cbbea1c0ca534f6a16f6fedc492">trace_formats</a> (void) const</td></tr>
<tr class="memdesc:a89e87cbbea1c0ca534f6a16f6fedc492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns format string for each column added to the trace.  <a href="#a89e87cbbea1c0ca534f6a16f6fedc492">More...</a><br /></td></tr>
<tr class="separator:a89e87cbbea1c0ca534f6a16f6fedc492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f233258ac5beba1f7159855428458e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#ab0f233258ac5beba1f7159855428458e">trace_values</a> (std::vector&lt; double &gt; &amp;values)=0</td></tr>
<tr class="memdesc:ab0f233258ac5beba1f7159855428458e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="classgeopm_1_1_controller.html">Controller</a> to get latest values to be added to the trace.  <a href="#ab0f233258ac5beba1f7159855428458e">More...</a><br /></td></tr>
<tr class="separator:ab0f233258ac5beba1f7159855428458e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca028a7d55f714d0b7429359c52f58f9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#aca028a7d55f714d0b7429359c52f58f9">enforce_policy</a> (const std::vector&lt; double &gt; &amp;policy) const =0</td></tr>
<tr class="memdesc:aca028a7d55f714d0b7429359c52f58f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enforce the policy one time with PlatformIO::write_control(). Called to enforce static policies in the absence of a <a class="el" href="classgeopm_1_1_controller.html">Controller</a>.  <a href="#aca028a7d55f714d0b7429359c52f58f9">More...</a><br /></td></tr>
<tr class="separator:aca028a7d55f714d0b7429359c52f58f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac5e2dcb4d69aa99bc6ef1326f85bfeeb"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#ac5e2dcb4d69aa99bc6ef1326f85bfeeb">agent_names</a> (void)</td></tr>
<tr class="separator:ac5e2dcb4d69aa99bc6ef1326f85bfeeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5603f79ef8370647f7122ee8588d063"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classgeopm_1_1_agent.html">Agent</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#ad5603f79ef8370647f7122ee8588d063">make_unique</a> (const std::string &amp;agent_name)</td></tr>
<tr class="separator:ad5603f79ef8370647f7122ee8588d063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c69d7a51b97857ca60882f5c784e64"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a57c69d7a51b97857ca60882f5c784e64">num_policy</a> (const std::map&lt; std::string, std::string &gt; &amp;dictionary)</td></tr>
<tr class="memdesc:a57c69d7a51b97857ca60882f5c784e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to look up the number of values in the policy vector sent down the tree for a specific <a class="el" href="classgeopm_1_1_agent.html">Agent</a>. This should be called with the dictionary returned by <a class="el" href="namespacegeopm.html#aee5418fb3e46bea801a04d97c4a7e131">agent_factory()</a>.dictionary(agent_name) for the <a class="el" href="classgeopm_1_1_agent.html">Agent</a> of interest.  <a href="#a57c69d7a51b97857ca60882f5c784e64">More...</a><br /></td></tr>
<tr class="separator:a57c69d7a51b97857ca60882f5c784e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af785c4f2aa3f8b8f40df9e2b390146d5"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#af785c4f2aa3f8b8f40df9e2b390146d5">num_policy</a> (const std::string &amp;agent_name)</td></tr>
<tr class="memdesc:af785c4f2aa3f8b8f40df9e2b390146d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to look up the number of values in the policy vector sent down the tree for a specific <a class="el" href="classgeopm_1_1_agent.html">Agent</a>.  <a href="#af785c4f2aa3f8b8f40df9e2b390146d5">More...</a><br /></td></tr>
<tr class="separator:af785c4f2aa3f8b8f40df9e2b390146d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946a1e98da35916924e0053e3d4e4021"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a946a1e98da35916924e0053e3d4e4021">num_sample</a> (const std::map&lt; std::string, std::string &gt; &amp;dictionary)</td></tr>
<tr class="memdesc:a946a1e98da35916924e0053e3d4e4021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to look up the number of values in the sample vector sent up the tree for a specific <a class="el" href="classgeopm_1_1_agent.html">Agent</a>. This should be called with the dictionary returned by <a class="el" href="namespacegeopm.html#aee5418fb3e46bea801a04d97c4a7e131">agent_factory()</a>.dictionary(agent_name) for the <a class="el" href="classgeopm_1_1_agent.html">Agent</a> of interest.  <a href="#a946a1e98da35916924e0053e3d4e4021">More...</a><br /></td></tr>
<tr class="separator:a946a1e98da35916924e0053e3d4e4021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108322d762e88089335bfa8d3c2c160b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a108322d762e88089335bfa8d3c2c160b">num_sample</a> (const std::string &amp;agent_name)</td></tr>
<tr class="memdesc:a108322d762e88089335bfa8d3c2c160b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to look up the number of values in the sample vector sent up the tree for a specific <a class="el" href="classgeopm_1_1_agent.html">Agent</a>.  <a href="#a108322d762e88089335bfa8d3c2c160b">More...</a><br /></td></tr>
<tr class="separator:a108322d762e88089335bfa8d3c2c160b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e51cd06a438f53c94e3869ffbdb21bc"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a1e51cd06a438f53c94e3869ffbdb21bc">policy_names</a> (const std::map&lt; std::string, std::string &gt; &amp;dictionary)</td></tr>
<tr class="memdesc:a1e51cd06a438f53c94e3869ffbdb21bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to look up the names of values in the policy vector sent down the tree for a specific <a class="el" href="classgeopm_1_1_agent.html">Agent</a>. This should be called with the dictionary returned by <a class="el" href="namespacegeopm.html#aee5418fb3e46bea801a04d97c4a7e131">agent_factory()</a>.dictionary(agent_name) for the <a class="el" href="classgeopm_1_1_agent.html">Agent</a> of interest.  <a href="#a1e51cd06a438f53c94e3869ffbdb21bc">More...</a><br /></td></tr>
<tr class="separator:a1e51cd06a438f53c94e3869ffbdb21bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0ec03ecc3c640348484417560ada1f"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a3a0ec03ecc3c640348484417560ada1f">policy_names</a> (const std::string &amp;agent_name)</td></tr>
<tr class="memdesc:a3a0ec03ecc3c640348484417560ada1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to look up the names of values in the policy vector sent down the tree for a specific <a class="el" href="classgeopm_1_1_agent.html">Agent</a>.  <a href="#a3a0ec03ecc3c640348484417560ada1f">More...</a><br /></td></tr>
<tr class="separator:a3a0ec03ecc3c640348484417560ada1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0a1beabd77152178aef6499113710e"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a3c0a1beabd77152178aef6499113710e">sample_names</a> (const std::map&lt; std::string, std::string &gt; &amp;dictionary)</td></tr>
<tr class="memdesc:a3c0a1beabd77152178aef6499113710e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to look up the names of values in the sample vector sent up the tree for a specific <a class="el" href="classgeopm_1_1_agent.html">Agent</a>. This should be called with the dictionary returned by <a class="el" href="namespacegeopm.html#aee5418fb3e46bea801a04d97c4a7e131">agent_factory()</a>.dictionary(agent_name) for the <a class="el" href="classgeopm_1_1_agent.html">Agent</a> of interest.  <a href="#a3c0a1beabd77152178aef6499113710e">More...</a><br /></td></tr>
<tr class="separator:a3c0a1beabd77152178aef6499113710e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d317dccf9d8c5b41c2e67b13a2bfab"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a17d317dccf9d8c5b41c2e67b13a2bfab">sample_names</a> (const std::string &amp;agent_name)</td></tr>
<tr class="memdesc:a17d317dccf9d8c5b41c2e67b13a2bfab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to look up the names of values in the sample vector sent up the tree for a specific <a class="el" href="classgeopm_1_1_agent.html">Agent</a>.  <a href="#a17d317dccf9d8c5b41c2e67b13a2bfab">More...</a><br /></td></tr>
<tr class="separator:a17d317dccf9d8c5b41c2e67b13a2bfab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f26cf0c9ddae0674f85898bf6ff75b4"><td class="memItemLeft" align="right" valign="top">static std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a5f26cf0c9ddae0674f85898bf6ff75b4">make_dictionary</a> (const std::vector&lt; std::string &gt; &amp;<a class="el" href="classgeopm_1_1_agent.html#a1e51cd06a438f53c94e3869ffbdb21bc">policy_names</a>, const std::vector&lt; std::string &gt; &amp;<a class="el" href="classgeopm_1_1_agent.html#a3c0a1beabd77152178aef6499113710e">sample_names</a>)</td></tr>
<tr class="memdesc:a5f26cf0c9ddae0674f85898bf6ff75b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to create a correctly-formatted dictionary for an <a class="el" href="classgeopm_1_1_agent.html">Agent</a> at the time the <a class="el" href="classgeopm_1_1_agent.html">Agent</a> is registered with the factory. Concrete <a class="el" href="classgeopm_1_1_agent.html">Agent</a> classes may provide <a class="el" href="classgeopm_1_1_agent.html#a1e51cd06a438f53c94e3869ffbdb21bc" title="Used to look up the names of values in the policy vector sent down the tree for a specific Agent...">policy_names()</a> and <a class="el" href="classgeopm_1_1_agent.html#a3c0a1beabd77152178aef6499113710e" title="Used to look up the names of values in the sample vector sent up the tree for a specific Agent...">sample_names()</a> methods to provide the vectors to be passed to this method.  <a href="#a5f26cf0c9ddae0674f85898bf6ff75b4">More...</a><br /></td></tr>
<tr class="separator:a5f26cf0c9ddae0674f85898bf6ff75b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9be17ea00e49470d47f75f13f2a021"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a5c9be17ea00e49470d47f75f13f2a021">aggregate_sample</a> (const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;in_sample, const std::vector&lt; std::function&lt; double(const std::vector&lt; double &gt; &amp;)&gt; &gt; &amp;agg_func, std::vector&lt; double &gt; &amp;out_sample)</td></tr>
<tr class="memdesc:a5c9be17ea00e49470d47f75f13f2a021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generically aggregate a vector of samples given a vector of aggregation functions. This helper method applies a different aggregation function to each sample element while aggregating across child samples.  <a href="#a5c9be17ea00e49470d47f75f13f2a021">More...</a><br /></td></tr>
<tr class="separator:a5c9be17ea00e49470d47f75f13f2a021"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa9eb2730eb7f3515f027555b2c4572de"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#aa9eb2730eb7f3515f027555b2c4572de">M_PLUGIN_PREFIX</a> = &quot;libgeopmagent_&quot;</td></tr>
<tr class="separator:aa9eb2730eb7f3515f027555b2c4572de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a63f44ae327dda74fa4b9642c580aece2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f44ae327dda74fa4b9642c580aece2">&#9670;&nbsp;</a></span>Agent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">geopm::Agent::Agent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae25bcbffb10acf177ac9294f24a6e211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25bcbffb10acf177ac9294f24a6e211">&#9670;&nbsp;</a></span>~Agent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual geopm::Agent::~Agent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4a4d973b78871fb7064aec3071958fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4d973b78871fb7064aec3071958fdd">&#9670;&nbsp;</a></span>adjust_platform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void geopm::Agent::adjust_platform </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_policy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjust the platform settings based the policy from above. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">policy</td><td>Settings for each control in the policy. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_agent.html#a271347842c0ed1a4d0298cf58a1cab2c">geopm::PowerBalancerAgent</a>, <a class="el" href="classgeopm_1_1_power_governor_agent.html#a9e7f31f78a99109da10c3c5ea27edd44">geopm::PowerGovernorAgent</a>, <a class="el" href="classgeopm_1_1_frequency_map_agent.html#a5364befc13864fc697df5406763a8c8d">geopm::FrequencyMapAgent</a>, and <a class="el" href="classgeopm_1_1_monitor_agent.html#ad25cdb172c66a01fb5a80e54e0ab1f04">geopm::MonitorAgent</a>.</p>

</div>
</div>
<a id="ac5e2dcb4d69aa99bc6ef1326f85bfeeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e2dcb4d69aa99bc6ef1326f85bfeeb">&#9670;&nbsp;</a></span>agent_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; geopm::Agent::agent_names </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a466fec62dd739ac1202bee83bb48a84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466fec62dd739ac1202bee83bb48a84c">&#9670;&nbsp;</a></span>aggregate_sample() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void geopm::Agent::aggregate_sample </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aggregate samples from children for the next level up the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_sample</td><td>Vector of sample vectors, one from each child. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_sample</td><td>Aggregated sample values to be sent up to the parent. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_agent.html#a0cc6ee69e969562bec65f97eadc93d54">geopm::PowerBalancerAgent</a>, <a class="el" href="classgeopm_1_1_power_governor_agent.html#a2f31c32cb9cf42d044e4bab677406187">geopm::PowerGovernorAgent</a>, <a class="el" href="classgeopm_1_1_frequency_map_agent.html#a18e1e33341e83d681253f6736ecb1314">geopm::FrequencyMapAgent</a>, and <a class="el" href="classgeopm_1_1_monitor_agent.html#a76637838f8cee9dbe24e21f17081f165">geopm::MonitorAgent</a>.</p>

</div>
</div>
<a id="a5c9be17ea00e49470d47f75f13f2a021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9be17ea00e49470d47f75f13f2a021">&#9670;&nbsp;</a></span>aggregate_sample() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void geopm::Agent::aggregate_sample </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::function&lt; double(const std::vector&lt; double &gt; &amp;)&gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>agg_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generically aggregate a vector of samples given a vector of aggregation functions. This helper method applies a different aggregation function to each sample element while aggregating across child samples. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_sample</td><td>Vector over children of the sample vector received from each child. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">agg_func</td><td>A vector over agent samples of the aggregation function that is applied. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_sample</td><td>Sample vector resulting from the applying the aggregation across child samples. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa31a7c9beb554f2e992b8ba3f550edd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa31a7c9beb554f2e992b8ba3f550edd0">&#9670;&nbsp;</a></span>do_send_policy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool geopm::Agent::do_send_policy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by <a class="el" href="classgeopm_1_1_controller.html">Controller</a> to determine if new policy values should be sent down the tree to the <a class="el" href="classgeopm_1_1_agent.html">Agent</a>'s children. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the policy has been updated since last call. </dd></dl>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_agent.html#a839f30f39ab7449c3ab4756cec6ae174">geopm::PowerBalancerAgent</a>, <a class="el" href="classgeopm_1_1_power_governor_agent.html#a476665b46782532cd1facee9d0912daa">geopm::PowerGovernorAgent</a>, <a class="el" href="classgeopm_1_1_frequency_map_agent.html#a3cbb9a07e373047526fa7b50eb795cbf">geopm::FrequencyMapAgent</a>, and <a class="el" href="classgeopm_1_1_monitor_agent.html#acfd8817e9b33c8a60107a821c6c86188">geopm::MonitorAgent</a>.</p>

</div>
</div>
<a id="a0ba9bc5764872dd01f8b02759f7f2563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba9bc5764872dd01f8b02759f7f2563">&#9670;&nbsp;</a></span>do_send_sample()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool geopm::Agent::do_send_sample </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if new samples were read since last call. </dd></dl>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_agent.html#abecc54aba3eccea0b6f9969540a75162">geopm::PowerBalancerAgent</a>, <a class="el" href="classgeopm_1_1_power_governor_agent.html#a0f8dd378362d551e19b9964568605047">geopm::PowerGovernorAgent</a>, <a class="el" href="classgeopm_1_1_frequency_map_agent.html#a69e20885ce3eb9a0f6d6ec81afff11e3">geopm::FrequencyMapAgent</a>, and <a class="el" href="classgeopm_1_1_monitor_agent.html#a7f662d0c6c5798731ab752bfdff495be">geopm::MonitorAgent</a>.</p>

</div>
</div>
<a id="afb97f2b7119ab9b38af3ccc18f935324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb97f2b7119ab9b38af3ccc18f935324">&#9670;&nbsp;</a></span>do_write_batch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool geopm::Agent::do_write_batch </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by the <a class="el" href="classgeopm_1_1_controller.html">Controller</a> to decide whether to call write_batch() to update platform controls. </p>
<dl class="section return"><dt>Returns</dt><dd>True if platform was adjusted, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_agent.html#a66a1d9bbecda85df6cd5ac4546f0ebdc">geopm::PowerBalancerAgent</a>, <a class="el" href="classgeopm_1_1_power_governor_agent.html#adcac0afac7c5b875c6dce46c1b6de2ba">geopm::PowerGovernorAgent</a>, <a class="el" href="classgeopm_1_1_frequency_map_agent.html#a2753629799aed8ac0d7e68c93bd10704">geopm::FrequencyMapAgent</a>, and <a class="el" href="classgeopm_1_1_monitor_agent.html#a59b4823577604fb19fde3f27ddffeaf0">geopm::MonitorAgent</a>.</p>

</div>
</div>
<a id="aca028a7d55f714d0b7429359c52f58f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca028a7d55f714d0b7429359c52f58f9">&#9670;&nbsp;</a></span>enforce_policy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void geopm::Agent::enforce_policy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>policy</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enforce the policy one time with PlatformIO::write_control(). Called to enforce static policies in the absence of a <a class="el" href="classgeopm_1_1_controller.html">Controller</a>. </p>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_agent.html#a6f6d8fac74a2d99ee5295031dc66d5e1">geopm::PowerBalancerAgent</a>, <a class="el" href="classgeopm_1_1_power_governor_agent.html#aa40c82334c92f6d923e02d5623e1904d">geopm::PowerGovernorAgent</a>, <a class="el" href="classgeopm_1_1_frequency_map_agent.html#ac19a056a490570a7e70cfca08f92e8d4">geopm::FrequencyMapAgent</a>, and <a class="el" href="classgeopm_1_1_monitor_agent.html#ae3034f33b75bbb32687344555121b866">geopm::MonitorAgent</a>.</p>

</div>
</div>
<a id="a2c94fff3ed8f580526e51aeb25cf4758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c94fff3ed8f580526e51aeb25cf4758">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void geopm::Agent::init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>fan_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_level_root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the level where this <a class="el" href="classgeopm_1_1_agent.html">Agent</a> is active and push signals/controls for that level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Level of the tree where this agent is active. Note that only agents at level zero execute <a class="el" href="classgeopm_1_1_agent.html#a223cbd5f3cd63829387a0b9a67166b19" title="Read signals from the platform and interpret/aggregate these signals to create a sample which can be ...">sample_platform()</a> and <a class="el" href="classgeopm_1_1_agent.html#a4a4d973b78871fb7064aec3071958fdd" title="Adjust the platform settings based the policy from above. ">adjust_platform()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fan_in</td><td>Vector over level giving the the number of Agents that report to each root <a class="el" href="classgeopm_1_1_agent.html">Agent</a> operating at the level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_level_root</td><td>True if the agent plays the role of root of the level. Only root agents for a level execute ascend() and descend(). </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_agent.html#a7ea24535b7f412749975201742130402">geopm::PowerBalancerAgent</a>, <a class="el" href="classgeopm_1_1_power_governor_agent.html#a0999719c1110fab35fbde5309b322058">geopm::PowerGovernorAgent</a>, <a class="el" href="classgeopm_1_1_frequency_map_agent.html#ad4c488b73074229577b1e12a7a66322f">geopm::FrequencyMapAgent</a>, and <a class="el" href="classgeopm_1_1_monitor_agent.html#a71fdfe5c9c00d0f235688c8038b908a7">geopm::MonitorAgent</a>.</p>

</div>
</div>
<a id="a5f26cf0c9ddae0674f85898bf6ff75b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f26cf0c9ddae0674f85898bf6ff75b4">&#9670;&nbsp;</a></span>make_dictionary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, std::string &gt; geopm::Agent::make_dictionary </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>policy_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sample_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to create a correctly-formatted dictionary for an <a class="el" href="classgeopm_1_1_agent.html">Agent</a> at the time the <a class="el" href="classgeopm_1_1_agent.html">Agent</a> is registered with the factory. Concrete <a class="el" href="classgeopm_1_1_agent.html">Agent</a> classes may provide <a class="el" href="classgeopm_1_1_agent.html#a1e51cd06a438f53c94e3869ffbdb21bc" title="Used to look up the names of values in the policy vector sent down the tree for a specific Agent...">policy_names()</a> and <a class="el" href="classgeopm_1_1_agent.html#a3c0a1beabd77152178aef6499113710e" title="Used to look up the names of values in the sample vector sent up the tree for a specific Agent...">sample_names()</a> methods to provide the vectors to be passed to this method. </p>

</div>
</div>
<a id="ad5603f79ef8370647f7122ee8588d063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5603f79ef8370647f7122ee8588d063">&#9670;&nbsp;</a></span>make_unique()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classgeopm_1_1_agent.html">Agent</a> &gt; geopm::Agent::make_unique </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>agent_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a57c69d7a51b97857ca60882f5c784e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c69d7a51b97857ca60882f5c784e64">&#9670;&nbsp;</a></span>num_policy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int geopm::Agent::num_policy </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>dictionary</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to look up the number of values in the policy vector sent down the tree for a specific <a class="el" href="classgeopm_1_1_agent.html">Agent</a>. This should be called with the dictionary returned by <a class="el" href="namespacegeopm.html#aee5418fb3e46bea801a04d97c4a7e131">agent_factory()</a>.dictionary(agent_name) for the <a class="el" href="classgeopm_1_1_agent.html">Agent</a> of interest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dictionary</td><td>Factory dictionary for the agent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af785c4f2aa3f8b8f40df9e2b390146d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af785c4f2aa3f8b8f40df9e2b390146d5">&#9670;&nbsp;</a></span>num_policy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int geopm::Agent::num_policy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>agent_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to look up the number of values in the policy vector sent down the tree for a specific <a class="el" href="classgeopm_1_1_agent.html">Agent</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">agent_name</td><td>Name of the agent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a946a1e98da35916924e0053e3d4e4021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946a1e98da35916924e0053e3d4e4021">&#9670;&nbsp;</a></span>num_sample() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int geopm::Agent::num_sample </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>dictionary</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to look up the number of values in the sample vector sent up the tree for a specific <a class="el" href="classgeopm_1_1_agent.html">Agent</a>. This should be called with the dictionary returned by <a class="el" href="namespacegeopm.html#aee5418fb3e46bea801a04d97c4a7e131">agent_factory()</a>.dictionary(agent_name) for the <a class="el" href="classgeopm_1_1_agent.html">Agent</a> of interest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dictionary</td><td>Factory dictionary for the agent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a108322d762e88089335bfa8d3c2c160b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108322d762e88089335bfa8d3c2c160b">&#9670;&nbsp;</a></span>num_sample() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int geopm::Agent::num_sample </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>agent_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to look up the number of values in the sample vector sent up the tree for a specific <a class="el" href="classgeopm_1_1_agent.html">Agent</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">agent_name</td><td>Name of the agent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e51cd06a438f53c94e3869ffbdb21bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e51cd06a438f53c94e3869ffbdb21bc">&#9670;&nbsp;</a></span>policy_names() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; geopm::Agent::policy_names </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>dictionary</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to look up the names of values in the policy vector sent down the tree for a specific <a class="el" href="classgeopm_1_1_agent.html">Agent</a>. This should be called with the dictionary returned by <a class="el" href="namespacegeopm.html#aee5418fb3e46bea801a04d97c4a7e131">agent_factory()</a>.dictionary(agent_name) for the <a class="el" href="classgeopm_1_1_agent.html">Agent</a> of interest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dictionary</td><td>Factory dictionary for the agent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a0ec03ecc3c640348484417560ada1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0ec03ecc3c640348484417560ada1f">&#9670;&nbsp;</a></span>policy_names() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; geopm::Agent::policy_names </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>agent_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to look up the names of values in the policy vector sent down the tree for a specific <a class="el" href="classgeopm_1_1_agent.html">Agent</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">agent_name</td><td>Name of the agent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1a830e95ed99627519e4f800d4d45bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a830e95ed99627519e4f800d4d45bc">&#9670;&nbsp;</a></span>report_header()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt; geopm::Agent::report_header </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Custom fields that will be added to the report header when this agent is used. </p>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_agent.html#a0e1424ddcf45cdf43da2d9421ff74daa">geopm::PowerBalancerAgent</a>, <a class="el" href="classgeopm_1_1_power_governor_agent.html#a3a498d3ab48d742a38df52a32fc53672">geopm::PowerGovernorAgent</a>, <a class="el" href="classgeopm_1_1_frequency_map_agent.html#a1c30c5e43b42002fe53f5b64a3f20ca2">geopm::FrequencyMapAgent</a>, and <a class="el" href="classgeopm_1_1_monitor_agent.html#a617507efdad33694b2fe08d5b9cbd382">geopm::MonitorAgent</a>.</p>

</div>
</div>
<a id="a8d89f3b7147ead870b3397ea9512a436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d89f3b7147ead870b3397ea9512a436">&#9670;&nbsp;</a></span>report_host()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt; geopm::Agent::report_host </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Custom fields for the host section of the report. </p>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_agent.html#ab2d08b33261e106ba6d1031df2a080d7">geopm::PowerBalancerAgent</a>, <a class="el" href="classgeopm_1_1_power_governor_agent.html#a1c8ad1182d33961507df831eb41e8888">geopm::PowerGovernorAgent</a>, <a class="el" href="classgeopm_1_1_frequency_map_agent.html#a71aaf7128106f3007419fb5cffebfc90">geopm::FrequencyMapAgent</a>, and <a class="el" href="classgeopm_1_1_monitor_agent.html#ac1bfa61ac26c478fb3ff9a8bc2181f20">geopm::MonitorAgent</a>.</p>

</div>
</div>
<a id="a80cedd11bbf8fb256f25da5e83175d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80cedd11bbf8fb256f25da5e83175d18">&#9670;&nbsp;</a></span>report_region()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::map&lt;uint64_t, std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt; &gt; geopm::Agent::report_region </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Custom fields for each region in the report. </p>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_agent.html#a8e87a6c4834b3f231d05baa7dad2b357">geopm::PowerBalancerAgent</a>, <a class="el" href="classgeopm_1_1_power_governor_agent.html#af8c436404bfadda4c38e7cf4fedd7a92">geopm::PowerGovernorAgent</a>, <a class="el" href="classgeopm_1_1_frequency_map_agent.html#a325e0d02b1380842e51137e0d68e55df">geopm::FrequencyMapAgent</a>, and <a class="el" href="classgeopm_1_1_monitor_agent.html#a58f24f99f0648a114a01a1163b49240f">geopm::MonitorAgent</a>.</p>

</div>
</div>
<a id="a3c0a1beabd77152178aef6499113710e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0a1beabd77152178aef6499113710e">&#9670;&nbsp;</a></span>sample_names() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; geopm::Agent::sample_names </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>dictionary</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to look up the names of values in the sample vector sent up the tree for a specific <a class="el" href="classgeopm_1_1_agent.html">Agent</a>. This should be called with the dictionary returned by <a class="el" href="namespacegeopm.html#aee5418fb3e46bea801a04d97c4a7e131">agent_factory()</a>.dictionary(agent_name) for the <a class="el" href="classgeopm_1_1_agent.html">Agent</a> of interest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dictionary</td><td>Factory dictionary for the agent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17d317dccf9d8c5b41c2e67b13a2bfab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d317dccf9d8c5b41c2e67b13a2bfab">&#9670;&nbsp;</a></span>sample_names() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; geopm::Agent::sample_names </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>agent_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to look up the names of values in the sample vector sent up the tree for a specific <a class="el" href="classgeopm_1_1_agent.html">Agent</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">agent_name</td><td>Name of the agent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a223cbd5f3cd63829387a0b9a67166b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223cbd5f3cd63829387a0b9a67166b19">&#9670;&nbsp;</a></span>sample_platform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void geopm::Agent::sample_platform </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_sample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read signals from the platform and interpret/aggregate these signals to create a sample which can be sent up the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sample</td><td>Vector of agent specific sample values to be sent up the tree. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_agent.html#a06862f0e21af10ebb55ef69cf7e82dae">geopm::PowerBalancerAgent</a>, <a class="el" href="classgeopm_1_1_power_governor_agent.html#aff9ef8cc890183958e4db2a7e52250d7">geopm::PowerGovernorAgent</a>, <a class="el" href="classgeopm_1_1_frequency_map_agent.html#a3241949020db9df0ee6b34fa2ad6c5eb">geopm::FrequencyMapAgent</a>, and <a class="el" href="classgeopm_1_1_monitor_agent.html#a4a912f38e226aff3a50a13f32ea11b1b">geopm::MonitorAgent</a>.</p>

</div>
</div>
<a id="a33501debc601b7a69bee243c9a3a2351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33501debc601b7a69bee243c9a3a2351">&#9670;&nbsp;</a></span>split_policy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void geopm::Agent::split_policy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by <a class="el" href="classgeopm_1_1_controller.html">Controller</a> to split policy for children at next level down the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_policy</td><td>Policy values from the parent. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_policy</td><td>Vector of policies to be sent to each child. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_agent.html#a96734c4a134010d1b5c08834693eefe0">geopm::PowerBalancerAgent</a>, <a class="el" href="classgeopm_1_1_power_governor_agent.html#a0709f42a6ca882fa6d6f90ffbea729f8">geopm::PowerGovernorAgent</a>, <a class="el" href="classgeopm_1_1_frequency_map_agent.html#ae70a2dd89b35f4554d27aae9dd311eda">geopm::FrequencyMapAgent</a>, and <a class="el" href="classgeopm_1_1_monitor_agent.html#a27e510ebe6c7140671e76e31f93c78af">geopm::MonitorAgent</a>.</p>

</div>
</div>
<a id="a89e87cbbea1c0ca534f6a16f6fedc492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e87cbbea1c0ca534f6a16f6fedc492">&#9670;&nbsp;</a></span>trace_formats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::function&lt; std::string(double)&gt; &gt; geopm::Agent::trace_formats </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns format string for each column added to the trace. </p>

<p>Reimplemented in <a class="el" href="classgeopm_1_1_power_balancer_agent.html#a02dc576fabd1206b8124a9a56590faf9">geopm::PowerBalancerAgent</a>, <a class="el" href="classgeopm_1_1_power_governor_agent.html#a235ec082019616aadaeb430cb51df2a4">geopm::PowerGovernorAgent</a>, <a class="el" href="classgeopm_1_1_frequency_map_agent.html#ab9cc136e5646502e0f30fb3052c358ea">geopm::FrequencyMapAgent</a>, and <a class="el" href="classgeopm_1_1_monitor_agent.html#ab2d89c4f01d354cdbe7cdcf5dccd3c2d">geopm::MonitorAgent</a>.</p>

</div>
</div>
<a id="a854cbf10df12e4e53b98a658779d6d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854cbf10df12e4e53b98a658779d6d53">&#9670;&nbsp;</a></span>trace_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; geopm::Agent::trace_names </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Column headers to be added to the trace. </p>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_agent.html#a1f9c536bf491868a924a4694451b4dad">geopm::PowerBalancerAgent</a>, <a class="el" href="classgeopm_1_1_power_governor_agent.html#a61b7ead286fcc8982ecd6334ba71f5cd">geopm::PowerGovernorAgent</a>, <a class="el" href="classgeopm_1_1_frequency_map_agent.html#a7826f0d21db738fec9ad6950c23f00cc">geopm::FrequencyMapAgent</a>, and <a class="el" href="classgeopm_1_1_monitor_agent.html#a456d548531dd52662fbd2a8ada7da5a3">geopm::MonitorAgent</a>.</p>

</div>
</div>
<a id="ab0f233258ac5beba1f7159855428458e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f233258ac5beba1f7159855428458e">&#9670;&nbsp;</a></span>trace_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void geopm::Agent::trace_values </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by <a class="el" href="classgeopm_1_1_controller.html">Controller</a> to get latest values to be added to the trace. </p>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_agent.html#a74f98b086ef93a48e04e37a6828ed3a5">geopm::PowerBalancerAgent</a>, <a class="el" href="classgeopm_1_1_power_governor_agent.html#a9eee399f447326e90ee0506039911316">geopm::PowerGovernorAgent</a>, <a class="el" href="classgeopm_1_1_frequency_map_agent.html#a00593adda6b963fad41c833b2a5a32dd">geopm::FrequencyMapAgent</a>, and <a class="el" href="classgeopm_1_1_monitor_agent.html#a0d6f276d48dddf4a0f5459e96022fc7b">geopm::MonitorAgent</a>.</p>

</div>
</div>
<a id="a76f4eb74c2f1c50b9c85fc988de8c4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f4eb74c2f1c50b9c85fc988de8c4c0">&#9670;&nbsp;</a></span>validate_policy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void geopm::Agent::validate_policy </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>policy</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by <a class="el" href="classgeopm_1_1_controller.html">Controller</a> to validate incoming policy values and configure defaults requested in incoming policy. Policy sender can request default value with 'NaN' at the desired offset in the policy vector. Returned policy should not contain 'NaN's and be consumeable by descend and adjust_platform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">policy</td><td>Policy replace NaN's with defaults. If a value of policy is not NaN but the value is not supported by the <a class="el" href="classgeopm_1_1_agent.html">Agent</a> the method will throw a geopm::Exception with error code GEOPM_ERROR_INVALID. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_agent.html#a15d68542efead72ee46c3bf612375798">geopm::PowerBalancerAgent</a>, <a class="el" href="classgeopm_1_1_power_governor_agent.html#ac8c82212e6b983aaed279716dbad9074">geopm::PowerGovernorAgent</a>, <a class="el" href="classgeopm_1_1_frequency_map_agent.html#a4ec7e1d086561776982cfb8e745f3a4d">geopm::FrequencyMapAgent</a>, and <a class="el" href="classgeopm_1_1_monitor_agent.html#adcc591f47d60be0b15a16cd1a6a96e86">geopm::MonitorAgent</a>.</p>

</div>
</div>
<a id="a0d2c88ac43e7ec80e92e541ddf093ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2c88ac43e7ec80e92e541ddf093ecc">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void geopm::Agent::wait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by <a class="el" href="classgeopm_1_1_controller.html">Controller</a> to wait for sample period to elapse. This controls the cadence of the <a class="el" href="classgeopm_1_1_controller.html">Controller</a> main loop. </p>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_agent.html#a6be46141cecafcbc4f786994a002bee3">geopm::PowerBalancerAgent</a>, <a class="el" href="classgeopm_1_1_power_governor_agent.html#a4581f936f857d8fdc4d3f9cff6119590">geopm::PowerGovernorAgent</a>, <a class="el" href="classgeopm_1_1_frequency_map_agent.html#a01869bb0e235cbb184ad7c4f13a631fd">geopm::FrequencyMapAgent</a>, and <a class="el" href="classgeopm_1_1_monitor_agent.html#ae0743824b4c58af0d0ece3b19546e31c">geopm::MonitorAgent</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa9eb2730eb7f3515f027555b2c4572de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9eb2730eb7f3515f027555b2c4572de">&#9670;&nbsp;</a></span>M_PLUGIN_PREFIX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string geopm::Agent::M_PLUGIN_PREFIX = &quot;libgeopmagent_&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_agent_8hpp_source.html">Agent.hpp</a></li>
<li>src/<a class="el" href="_agent_8cpp.html">Agent.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
