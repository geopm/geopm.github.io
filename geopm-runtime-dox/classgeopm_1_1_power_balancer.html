<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>geopm: geopm::PowerBalancer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">geopm<span id="projectnumber">&#160;3.1.1.dev554+g95167ca4</span>
   </div>
   <div id="projectbrief">GEOPM - Global Extensible Open Power Manager</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegeopm.html">geopm</a></li><li class="navelem"><a class="el" href="classgeopm_1_1_power_balancer.html">PowerBalancer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classgeopm_1_1_power_balancer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">geopm::PowerBalancer Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Stay within a power cap but redistribute power to optimize performance. An average per compute node power maximum is maintained, but individual nodes will be allowed above or below this average.  
 <a href="classgeopm_1_1_power_balancer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_power_balancer_8hpp_source.html">PowerBalancer.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for geopm::PowerBalancer:</div>
<div class="dyncontent">
<div class="center"><img src="classgeopm_1_1_power_balancer__inherit__graph.png" border="0" usemap="#ageopm_1_1_power_balancer_inherit__map" alt="Inheritance graph"/></div>
<map name="ageopm_1_1_power_balancer_inherit__map" id="ageopm_1_1_power_balancer_inherit__map">
<area shape="rect" title="Stay within a power cap but redistribute power to optimize performance. An average per compute node p..." alt="" coords="18,5,190,31"/>
<area shape="rect" href="classgeopm_1_1_power_balancer_imp.html" title=" " alt="" coords="5,79,203,104"/>
<area shape="poly" title=" " alt="" coords="107,44,107,79,101,79,101,44"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a990b8da3a1c2a3a8f2986fbed9f1f8e2" id="r_a990b8da3a1c2a3a8f2986fbed9f1f8e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_power_balancer.html#a990b8da3a1c2a3a8f2986fbed9f1f8e2">PowerBalancer</a> ()=default</td></tr>
<tr class="memdesc:a990b8da3a1c2a3a8f2986fbed9f1f8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a IPowerBalancer object.  <br /></td></tr>
<tr class="separator:a990b8da3a1c2a3a8f2986fbed9f1f8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4599b55e3f9b129927461e6dea779eed" id="r_a4599b55e3f9b129927461e6dea779eed"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_power_balancer.html#a4599b55e3f9b129927461e6dea779eed">~PowerBalancer</a> ()=default</td></tr>
<tr class="memdesc:a4599b55e3f9b129927461e6dea779eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a IPowerBalancer object.  <br /></td></tr>
<tr class="separator:a4599b55e3f9b129927461e6dea779eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b98f4cf13bf0bdd785790d30fd14ea" id="r_a25b98f4cf13bf0bdd785790d30fd14ea"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_power_balancer.html#a25b98f4cf13bf0bdd785790d30fd14ea">power_cap</a> (double cap)=0</td></tr>
<tr class="memdesc:a25b98f4cf13bf0bdd785790d30fd14ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should be called at the start of application execution with the average power cap across compute nodes. Should be called at the end of the second phase of execution to note that the power savings made across all compute nodes has been evenly redistributed.  <br /></td></tr>
<tr class="separator:a25b98f4cf13bf0bdd785790d30fd14ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b198100093c8cd3563dc1114e149c1" id="r_a58b198100093c8cd3563dc1114e149c1"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_power_balancer.html#a58b198100093c8cd3563dc1114e149c1">power_cap</a> (void) const =0</td></tr>
<tr class="memdesc:a58b198100093c8cd3563dc1114e149c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current power cap which cannot be exceeded without breaking contract that the average power budget across all compute nodes is maintained.  <br /></td></tr>
<tr class="separator:a58b198100093c8cd3563dc1114e149c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf84174bff51eddc5ab995ff6992b75d" id="r_aaf84174bff51eddc5ab995ff6992b75d"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_power_balancer.html#aaf84174bff51eddc5ab995ff6992b75d">power_limit</a> (void) const =0</td></tr>
<tr class="memdesc:aaf84174bff51eddc5ab995ff6992b75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current power limit prescribed for this node.  <br /></td></tr>
<tr class="separator:aaf84174bff51eddc5ab995ff6992b75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1241a9b3105bc51cc9a50f897cdb9d1" id="r_ab1241a9b3105bc51cc9a50f897cdb9d1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_power_balancer.html#ab1241a9b3105bc51cc9a50f897cdb9d1">power_limit_adjusted</a> (double limit)=0</td></tr>
<tr class="memdesc:ab1241a9b3105bc51cc9a50f897cdb9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify power balancer that a new limit has been set with the governor.  <br /></td></tr>
<tr class="separator:ab1241a9b3105bc51cc9a50f897cdb9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5660af0029b304ed90c0b1b557932e" id="r_a7c5660af0029b304ed90c0b1b557932e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_power_balancer.html#a7c5660af0029b304ed90c0b1b557932e">is_runtime_stable</a> (double measured_runtime)=0</td></tr>
<tr class="memdesc:a7c5660af0029b304ed90c0b1b557932e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the object with a runtime measured under the current power limit and test if the current runtime sample is reliable such that a call <a class="el" href="classgeopm_1_1_power_balancer.html#a543328bb4f42dc573d9ca5cff470c4ea" title="Return the expected execution time of an application epoch under the current power limit.">runtime_sample()</a> can be made.  <br /></td></tr>
<tr class="separator:a7c5660af0029b304ed90c0b1b557932e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543328bb4f42dc573d9ca5cff470c4ea" id="r_a543328bb4f42dc573d9ca5cff470c4ea"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_power_balancer.html#a543328bb4f42dc573d9ca5cff470c4ea">runtime_sample</a> (void) const =0</td></tr>
<tr class="memdesc:a543328bb4f42dc573d9ca5cff470c4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the expected execution time of an application epoch under the current power limit.  <br /></td></tr>
<tr class="separator:a543328bb4f42dc573d9ca5cff470c4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46013a55e94d8b0c795b904088a286c2" id="r_a46013a55e94d8b0c795b904088a286c2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_power_balancer.html#a46013a55e94d8b0c795b904088a286c2">calculate_runtime_sample</a> (void)=0</td></tr>
<tr class="memdesc:a46013a55e94d8b0c795b904088a286c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample the measured runtimes under the current power cap in the first phase of execution. This measurement will be aggregated across all compute nodes to find the largest runtime measured.  <br /></td></tr>
<tr class="separator:a46013a55e94d8b0c795b904088a286c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c23de5386f1d7be2c8d09d53f2c4e9d" id="r_a7c23de5386f1d7be2c8d09d53f2c4e9d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_power_balancer.html#a7c23de5386f1d7be2c8d09d53f2c4e9d">target_runtime</a> (double largest_runtime)=0</td></tr>
<tr class="separator:a7c23de5386f1d7be2c8d09d53f2c4e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddcd8d50f9c64c905641a79d2c87517" id="r_a9ddcd8d50f9c64c905641a79d2c87517"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_power_balancer.html#a9ddcd8d50f9c64c905641a79d2c87517">is_target_met</a> (double measured_runtime)=0</td></tr>
<tr class="memdesc:a9ddcd8d50f9c64c905641a79d2c87517"><td class="mdescLeft">&#160;</td><td class="mdescRight">During the second phase of execution the power limit is decreased until the epoch runtime on the compute node under management has increased to the runtime of the slowest compute node. This method is used to update the object with a new measurement and also test if the current power limit meets the requirements. If the method returns false, then the value returned by <a class="el" href="classgeopm_1_1_power_balancer.html#aaf84174bff51eddc5ab995ff6992b75d" title="Returns the current power limit prescribed for this node.">power_limit()</a> may have been updated. The new power limit should be enforced for the next epoch execution.  <br /></td></tr>
<tr class="separator:a9ddcd8d50f9c64c905641a79d2c87517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc53811113f4cb2c07c53859a09052b" id="r_a4dc53811113f4cb2c07c53859a09052b"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_power_balancer.html#a4dc53811113f4cb2c07c53859a09052b">power_slack</a> (void)=0</td></tr>
<tr class="memdesc:a4dc53811113f4cb2c07c53859a09052b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the difference between the last power cap setting and the current power limit. If this method is called and it returns zero then the trial delta used to lower the power limit is reduced by a factor of two.  <br /></td></tr>
<tr class="separator:a4dc53811113f4cb2c07c53859a09052b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a77416cf4c4099d1e630f20f66fde4b4c" id="r_a77416cf4c4099d1e630f20f66fde4b4c"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classgeopm_1_1_power_balancer.html">PowerBalancer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_power_balancer.html#a77416cf4c4099d1e630f20f66fde4b4c">make_unique</a> (double ctl_latency)</td></tr>
<tr class="memdesc:a77416cf4c4099d1e630f20f66fde4b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a unique_ptr to a concrete object constructed using the underlying implementation.  <br /></td></tr>
<tr class="separator:a77416cf4c4099d1e630f20f66fde4b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba4d60f2cecb84be79e6536cf822fd4" id="r_a3ba4d60f2cecb84be79e6536cf822fd4"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classgeopm_1_1_power_balancer.html">PowerBalancer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_power_balancer.html#a3ba4d60f2cecb84be79e6536cf822fd4">make_shared</a> (double ctl_latency)</td></tr>
<tr class="memdesc:a3ba4d60f2cecb84be79e6536cf822fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shared_ptr to a concrete object constructed using the underlying implementation.  <br /></td></tr>
<tr class="separator:a3ba4d60f2cecb84be79e6536cf822fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Stay within a power cap but redistribute power to optimize performance. An average per compute node power maximum is maintained, but individual nodes will be allowed above or below this average. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a990b8da3a1c2a3a8f2986fbed9f1f8e2" name="a990b8da3a1c2a3a8f2986fbed9f1f8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990b8da3a1c2a3a8f2986fbed9f1f8e2">&#9670;&#160;</a></span>PowerBalancer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">geopm::PowerBalancer::PowerBalancer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a IPowerBalancer object. </p>

</div>
</div>
<a id="a4599b55e3f9b129927461e6dea779eed" name="a4599b55e3f9b129927461e6dea779eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4599b55e3f9b129927461e6dea779eed">&#9670;&#160;</a></span>~PowerBalancer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual geopm::PowerBalancer::~PowerBalancer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy a IPowerBalancer object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a46013a55e94d8b0c795b904088a286c2" name="a46013a55e94d8b0c795b904088a286c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46013a55e94d8b0c795b904088a286c2">&#9670;&#160;</a></span>calculate_runtime_sample()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void geopm::PowerBalancer::calculate_runtime_sample </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sample the measured runtimes under the current power cap in the first phase of execution. This measurement will be aggregated across all compute nodes to find the largest runtime measured. </p>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_imp.html#a0f9e14771035975428d7becefd0bee3f">geopm::PowerBalancerImp</a>.</p>

</div>
</div>
<a id="a7c5660af0029b304ed90c0b1b557932e" name="a7c5660af0029b304ed90c0b1b557932e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5660af0029b304ed90c0b1b557932e">&#9670;&#160;</a></span>is_runtime_stable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool geopm::PowerBalancer::is_runtime_stable </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>measured_runtime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the object with a runtime measured under the current power limit and test if the current runtime sample is reliable such that a call <a class="el" href="classgeopm_1_1_power_balancer.html#a543328bb4f42dc573d9ca5cff470c4ea" title="Return the expected execution time of an application epoch under the current power limit.">runtime_sample()</a> can be made. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">measured_runtime</td><td>Most recent measurement of the execution time for an epoch on the node being managed under the current power limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a stable measurement of expected runtime for an epoch can be made with the <a class="el" href="classgeopm_1_1_power_balancer.html#a543328bb4f42dc573d9ca5cff470c4ea" title="Return the expected execution time of an application epoch under the current power limit.">runtime_sample()</a> method, and false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_imp.html#adb91df72877d1b8400c563e9e1b64804">geopm::PowerBalancerImp</a>.</p>

</div>
</div>
<a id="a9ddcd8d50f9c64c905641a79d2c87517" name="a9ddcd8d50f9c64c905641a79d2c87517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ddcd8d50f9c64c905641a79d2c87517">&#9670;&#160;</a></span>is_target_met()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool geopm::PowerBalancer::is_target_met </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>measured_runtime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>During the second phase of execution the power limit is decreased until the epoch runtime on the compute node under management has increased to the runtime of the slowest compute node. This method is used to update the object with a new measurement and also test if the current power limit meets the requirements. If the method returns false, then the value returned by <a class="el" href="classgeopm_1_1_power_balancer.html#aaf84174bff51eddc5ab995ff6992b75d" title="Returns the current power limit prescribed for this node.">power_limit()</a> may have been updated. The new power limit should be enforced for the next epoch execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">measured_runtime</td><td>Most recent measurement of the execution time for an epoch on the node being managed under the current power limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the current power limit is reliably close to the target runtime and excess power should be sent up to the root to be redistributed, and false if more trials are required. </dd></dl>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_imp.html#ac168b31048ab2fd283d9c0178a0cdb76">geopm::PowerBalancerImp</a>.</p>

</div>
</div>
<a id="a3ba4d60f2cecb84be79e6536cf822fd4" name="a3ba4d60f2cecb84be79e6536cf822fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba4d60f2cecb84be79e6536cf822fd4">&#9670;&#160;</a></span>make_shared()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classgeopm_1_1_power_balancer.html">PowerBalancer</a> &gt; geopm::PowerBalancer::make_shared </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ctl_latency</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a shared_ptr to a concrete object constructed using the underlying implementation. </p>

</div>
</div>
<a id="a77416cf4c4099d1e630f20f66fde4b4c" name="a77416cf4c4099d1e630f20f66fde4b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77416cf4c4099d1e630f20f66fde4b4c">&#9670;&#160;</a></span>make_unique()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classgeopm_1_1_power_balancer.html">PowerBalancer</a> &gt; geopm::PowerBalancer::make_unique </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ctl_latency</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a unique_ptr to a concrete object constructed using the underlying implementation. </p>

</div>
</div>
<a id="a25b98f4cf13bf0bdd785790d30fd14ea" name="a25b98f4cf13bf0bdd785790d30fd14ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b98f4cf13bf0bdd785790d30fd14ea">&#9670;&#160;</a></span>power_cap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void geopm::PowerBalancer::power_cap </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Should be called at the start of application execution with the average power cap across compute nodes. Should be called at the end of the second phase of execution to note that the power savings made across all compute nodes has been evenly redistributed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">power_cap</td><td>The new maximum power limit equal to the current power limit plus the amount of power saved that is being redistributed. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_imp.html#a51e9b61cb646202c093d25b168861271">geopm::PowerBalancerImp</a>.</p>

</div>
</div>
<a id="a58b198100093c8cd3563dc1114e149c1" name="a58b198100093c8cd3563dc1114e149c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b198100093c8cd3563dc1114e149c1">&#9670;&#160;</a></span>power_cap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double geopm::PowerBalancer::power_cap </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current power cap which cannot be exceeded without breaking contract that the average power budget across all compute nodes is maintained. </p>
<dl class="section return"><dt>Returns</dt><dd>The current value of the power cap. </dd></dl>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_imp.html#a4da33e6ec47bb1007a6fa7d9fed759cd">geopm::PowerBalancerImp</a>.</p>

</div>
</div>
<a id="aaf84174bff51eddc5ab995ff6992b75d" name="aaf84174bff51eddc5ab995ff6992b75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf84174bff51eddc5ab995ff6992b75d">&#9670;&#160;</a></span>power_limit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double geopm::PowerBalancer::power_limit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current power limit prescribed for this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The current power limit in units of Watts. </dd></dl>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_imp.html#a98361888874560337cd58387e619cd0d">geopm::PowerBalancerImp</a>.</p>

</div>
</div>
<a id="ab1241a9b3105bc51cc9a50f897cdb9d1" name="ab1241a9b3105bc51cc9a50f897cdb9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1241a9b3105bc51cc9a50f897cdb9d1">&#9670;&#160;</a></span>power_limit_adjusted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void geopm::PowerBalancer::power_limit_adjusted </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify power balancer that a new limit has been set with the governor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">limit</td><td>limit that was set. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_imp.html#a8a7fe1a7b051170c0f534e67630b7fbb">geopm::PowerBalancerImp</a>.</p>

</div>
</div>
<a id="a4dc53811113f4cb2c07c53859a09052b" name="a4dc53811113f4cb2c07c53859a09052b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc53811113f4cb2c07c53859a09052b">&#9670;&#160;</a></span>power_slack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double geopm::PowerBalancer::power_slack </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the difference between the last power cap setting and the current power limit. If this method is called and it returns zero then the trial delta used to lower the power limit is reduced by a factor of two. </p>
<dl class="section return"><dt>Returns</dt><dd>The difference between the last power cap and the current power limit in units of Watts. </dd></dl>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_imp.html#aaee8ece95c8c020a2a7844e9f61c2b60">geopm::PowerBalancerImp</a>.</p>

</div>
</div>
<a id="a543328bb4f42dc573d9ca5cff470c4ea" name="a543328bb4f42dc573d9ca5cff470c4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543328bb4f42dc573d9ca5cff470c4ea">&#9670;&#160;</a></span>runtime_sample()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double geopm::PowerBalancer::runtime_sample </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the expected execution time of an application epoch under the current power limit. </p>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_imp.html#aeaeca591b7009d57d873eb2541ac7e08">geopm::PowerBalancerImp</a>.</p>

</div>
</div>
<a id="a7c23de5386f1d7be2c8d09d53f2c4e9d" name="a7c23de5386f1d7be2c8d09d53f2c4e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c23de5386f1d7be2c8d09d53f2c4e9d">&#9670;&#160;</a></span>target_runtime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void geopm::PowerBalancer::target_runtime </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>largest_runtime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Set</td><td>the target runtime which is the largest epoch execution time measured by any compute node since the application began or the last global increase to the power budget. </td></tr>
    <tr><td class="paramname">largest_runtime</td><td>The largest expected runtime for one epoch across all compute nodes under the current power budget. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classgeopm_1_1_power_balancer_imp.html#a0f3852a14b3525d3f4bcfbb61922578b">geopm::PowerBalancerImp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_power_balancer_8hpp_source.html">PowerBalancer.hpp</a></li>
<li><a class="el" href="_power_balancer_8cpp.html">PowerBalancer.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
